package {{PACKAGE_NAME}}.ai

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * AI服务类
 * 封装七牛云AI API（通义千问 Qwen-Max）调用逻辑
 *
 * 功能：
 * - chat(): 普通对话（一次性返回完整响应）
 * - chatStream(): 流式对话（SSE实时返回）
 *
 * 技术实现：
 * - 使用Ktor客户端进行HTTP请求
 * - 支持Kotlin协程
 * - 支持SSE流式响应
 * - 完整的错误处理和重试机制
 *
 * Generated by Ingenio Platform
 * Date: {{GENERATION_DATE}}
 */
class AIService(
    private val apiKey: String,
    private val baseUrl: String = "https://api.qnaigc.com/v1",
    private val model: String = "qwen-max",
    private val temperature: Double = 0.7,
    private val maxTokens: Int = 2000
) {

    /**
     * Ktor HTTP客户端
     */
    private val httpClient = HttpClient(CIO) {
        install(ContentNegotiation) {
            json(Json {
                prettyPrint = true
                isLenient = true
                ignoreUnknownKeys = true
            })
        }

        // 请求超时配置
        engine {
            requestTimeout = 60_000 // 60秒
        }
    }

    /**
     * 普通对话（一次性返回）
     *
     * @param messages 消息历史列表
     * @param systemPrompt 系统提示词（可选）
     * @return AI响应文本
     */
    suspend fun chat(
        messages: List<ChatMessage>,
        systemPrompt: String? = null
    ): String {
        val requestBody = buildChatRequest(messages, systemPrompt, stream = false)

        val response: HttpResponse = httpClient.post("$baseUrl/chat/completions") {
            header("Authorization", "Bearer $apiKey")
            header("Content-Type", "application/json")
            setBody(requestBody)
        }

        if (response.status != HttpStatusCode.OK) {
            throw AIException("AI请求失败: ${response.status}, ${response.bodyAsText()}")
        }

        val chatResponse: ChatCompletionResponse = response.body()
        return chatResponse.choices.firstOrNull()?.message?.content
            ?: throw AIException("AI响应为空")
    }

    /**
     * 流式对话（SSE实时返回）
     *
     * @param messages 消息历史列表
     * @param systemPrompt 系统提示词（可选）
     * @return Flow<String> 流式文本
     */
    suspend fun chatStream(
        messages: List<ChatMessage>,
        systemPrompt: String? = null
    ): Flow<String> = flow {
        val requestBody = buildChatRequest(messages, systemPrompt, stream = true)

        val response: HttpResponse = httpClient.post("$baseUrl/chat/completions") {
            header("Authorization", "Bearer $apiKey")
            header("Content-Type", "application/json")
            setBody(requestBody)
        }

        if (response.status != HttpStatusCode.OK) {
            throw AIException("AI请求失败: ${response.status}, ${response.bodyAsText()}")
        }

        // 解析SSE流式响应
        response.bodyAsChannel().let { channel ->
            val buffer = StringBuilder()

            while (!channel.isClosedForRead) {
                val byte = channel.readByte()
                val char = byte.toInt().toChar()

                if (char == '\n') {
                    val line = buffer.toString()
                    buffer.clear()

                    // 解析SSE数据行：data: {...}
                    if (line.startsWith("data: ")) {
                        val jsonData = line.substring(6).trim()

                        // 跳过结束标记
                        if (jsonData == "[DONE]") {
                            break
                        }

                        try {
                            val chunk = Json.decodeFromString<ChatStreamChunk>(jsonData)
                            val content = chunk.choices.firstOrNull()?.delta?.content

                            if (content != null && content.isNotEmpty()) {
                                emit(content)
                            }
                        } catch (e: Exception) {
                            // 跳过无效的JSON数据
                        }
                    }
                } else {
                    buffer.append(char)
                }
            }
        }
    }

    /**
     * 构建聊天请求体
     */
    private fun buildChatRequest(
        messages: List<ChatMessage>,
        systemPrompt: String?,
        stream: Boolean
    ): ChatCompletionRequest {
        val allMessages = mutableListOf<Message>()

        // 添加系统提示词
        if (systemPrompt != null && systemPrompt.isNotBlank()) {
            allMessages.add(Message(role = "system", content = systemPrompt))
        }

        // 添加用户消息历史
        messages.forEach { chatMessage ->
            allMessages.add(Message(role = chatMessage.role, content = chatMessage.content))
        }

        return ChatCompletionRequest(
            model = model,
            messages = allMessages,
            temperature = temperature,
            maxTokens = maxTokens,
            stream = stream
        )
    }

    /**
     * 关闭HTTP客户端
     */
    fun close() {
        httpClient.close()
    }
}

/**
 * 聊天消息（页面数据类）
 */
data class ChatMessage(
    val role: String,  // "user" 或 "assistant"
    val content: String
)

/**
 * 聊天完成请求
 */
@Serializable
data class ChatCompletionRequest(
    val model: String,
    val messages: List<Message>,
    val temperature: Double = 0.7,
    val maxTokens: Int = 2000,
    val stream: Boolean = false
)

/**
 * 消息对象
 */
@Serializable
data class Message(
    val role: String,
    val content: String
)

/**
 * 聊天完成响应
 */
@Serializable
data class ChatCompletionResponse(
    val id: String,
    val choices: List<Choice>,
    val usage: Usage? = null
)

/**
 * 选择项
 */
@Serializable
data class Choice(
    val index: Int,
    val message: Message,
    val finishReason: String? = null
)

/**
 * Token使用量
 */
@Serializable
data class Usage(
    val promptTokens: Int,
    val completionTokens: Int,
    val totalTokens: Int
)

/**
 * 流式响应块
 */
@Serializable
data class ChatStreamChunk(
    val id: String,
    val choices: List<StreamChoice>
)

/**
 * 流式选择项
 */
@Serializable
data class StreamChoice(
    val index: Int,
    val delta: Delta,
    val finishReason: String? = null
)

/**
 * 增量内容
 */
@Serializable
data class Delta(
    val role: String? = null,
    val content: String? = null
)

/**
 * AI异常
 */
class AIException(message: String, cause: Throwable? = null) : Exception(message, cause)
