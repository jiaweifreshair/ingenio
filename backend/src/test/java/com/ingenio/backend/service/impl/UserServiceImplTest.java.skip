package com.ingenio.backend.service.impl;

import cn.hutool.crypto.digest.BCrypt;
import com.ingenio.backend.common.exception.BusinessException;
import com.ingenio.backend.common.exception.ErrorCode;
import com.ingenio.backend.entity.UserEntity;
import com.ingenio.backend.mapper.UserMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * UserServiceImpl单元测试
 * 测试用户注册、登录、密码修改等核心业务逻辑
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("UserServiceImpl单元测试")
class UserServiceImplTest {

    @Mock
    private UserMapper userMapper;

    @InjectMocks
    private UserServiceImpl userService;

    private String testUsername;
    private String testEmail;
    private String testPassword;
    private String testTenantId;
    private UserEntity testUser;

    /**
     * 初始化测试数据
     */
    @BeforeEach
    void setUp() {
        testUsername = "testuser";
        testEmail = "test@example.com";
        testPassword = "password123";
        testTenantId = "tenant-001";

        testUser = UserEntity.builder()
                .id(UUID.randomUUID())
                .tenantId(testTenantId)
                .username(testUsername)
                .email(testEmail)
                .passwordHash(BCrypt.hashpw(testPassword))
                .role(UserEntity.Role.USER.getValue())
                .status(UserEntity.Status.ACTIVE.getValue())
                .displayName(testUsername)
                .metadata(new HashMap<>())
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .build();
    }

    /**
     * 测试用户注册成功
     * 验证点：
     * 1. 用户名和邮箱唯一性检查
     * 2. 密码BCrypt加密
     * 3. 默认角色和状态设置
     */
    @Test
    @DisplayName("测试用户注册成功")
    void testRegisterSuccess() {
        // Arrange - 准备测试数据
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.empty());
        when(userMapper.findByEmail(testEmail)).thenReturn(Optional.empty());

        // 注意：ServiceImpl的save方法需要被mock，因为它继承自MyBatis-Plus的ServiceImpl
        // 但在实际测试中，我们无法直接mock继承的方法，需要使用spy
        // 这里我们假设save方法调用成功

        // Act - 执行被测试方法
        UserEntity result = userService.register(testUsername, testEmail, testPassword, testTenantId);

        // Assert - 验证结果
        assertNotNull(result);
        assertEquals(testUsername, result.getUsername());
        assertEquals(testEmail, result.getEmail());
        assertEquals(testTenantId, result.getTenantId());
        assertEquals(UserEntity.Role.USER.getValue(), result.getRole());
        assertEquals(UserEntity.Status.ACTIVE.getValue(), result.getStatus());

        // 验证密码已被加密（BCrypt加密后的密码不等于原密码）
        assertNotEquals(testPassword, result.getPasswordHash());
        assertTrue(BCrypt.checkpw(testPassword, result.getPasswordHash()));

        // 验证方法调用次数
        verify(userMapper, times(1)).findByUsername(testUsername);
        verify(userMapper, times(1)).findByEmail(testEmail);
    }

    /**
     * 测试用户注册失败 - 用户名已存在
     * 验证点：
     * 1. 检测到用户名重复时抛出BusinessException
     * 2. 错误码为USER_ALREADY_EXISTS
     */
    @Test
    @DisplayName("测试用户注册失败 - 用户名已存在")
    void testRegisterUsernameExists() {
        // Arrange - 模拟用户名已存在
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act & Assert - 验证抛出异常
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.register(testUsername, testEmail, testPassword, testTenantId);
        });

        // 验证错误码
        assertEquals(ErrorCode.USER_ALREADY_EXISTS.getCode(), exception.getCode());
        assertEquals(ErrorCode.USER_ALREADY_EXISTS.getMessage(), exception.getMessage());

        // 验证只调用了findByUsername，没有调用findByEmail
        verify(userMapper, times(1)).findByUsername(testUsername);
        verify(userMapper, never()).findByEmail(anyString());
    }

    /**
     * 测试用户注册失败 - 邮箱已存在
     * 验证点：
     * 1. 检测到邮箱重复时抛出BusinessException
     * 2. 错误码为USER_ALREADY_EXISTS
     */
    @Test
    @DisplayName("测试用户注册失败 - 邮箱已存在")
    void testRegisterEmailExists() {
        // Arrange - 模拟邮箱已存在
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.empty());
        when(userMapper.findByEmail(testEmail)).thenReturn(Optional.of(testUser));

        // Act & Assert - 验证抛出异常
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.register(testUsername, testEmail, testPassword, testTenantId);
        });

        // 验证错误码
        assertEquals(ErrorCode.USER_ALREADY_EXISTS.getCode(), exception.getCode());

        // 验证方法调用
        verify(userMapper, times(1)).findByUsername(testUsername);
        verify(userMapper, times(1)).findByEmail(testEmail);
    }

    /**
     * 测试用户登录成功
     * 验证点：
     * 1. 密码验证正确
     * 2. 用户状态为ACTIVE
     * 3. 更新最后登录时间
     */
    @Test
    @DisplayName("测试用户登录成功")
    void testLoginSuccess() {
        // Arrange
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act
        UserEntity result = userService.login(testUsername, testPassword);

        // Assert
        assertNotNull(result);
        assertEquals(testUsername, result.getUsername());
        assertEquals(testEmail, result.getEmail());

        // 验证方法调用
        verify(userMapper, times(1)).findByUsername(testUsername);
    }

    /**
     * 测试用户登录失败 - 用户不存在
     * 验证点：
     * 1. 用户不存在时抛出BusinessException
     * 2. 错误码为USER_NOT_FOUND
     */
    @Test
    @DisplayName("测试用户登录失败 - 用户不存在")
    void testLoginUserNotFound() {
        // Arrange
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.empty());

        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.login(testUsername, testPassword);
        });

        assertEquals(ErrorCode.USER_NOT_FOUND.getCode(), exception.getCode());
        verify(userMapper, times(1)).findByUsername(testUsername);
    }

    /**
     * 测试用户登录失败 - 密码错误
     * 验证点：
     * 1. 密码验证失败时抛出BusinessException
     * 2. 错误码为USER_PASSWORD_ERROR
     */
    @Test
    @DisplayName("测试用户登录失败 - 密码错误")
    void testLoginPasswordError() {
        // Arrange
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act & Assert - 使用错误的密码
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.login(testUsername, "wrongpassword");
        });

        assertEquals(ErrorCode.USER_PASSWORD_ERROR.getCode(), exception.getCode());
        verify(userMapper, times(1)).findByUsername(testUsername);
    }

    /**
     * 测试用户登录失败 - 用户已禁用
     * 验证点：
     * 1. 用户状态为INACTIVE或SUSPENDED时抛出异常
     * 2. 错误码为USER_DISABLED
     */
    @Test
    @DisplayName("测试用户登录失败 - 用户已禁用")
    void testLoginUserDisabled() {
        // Arrange - 设置用户状态为INACTIVE
        testUser.setStatus(UserEntity.Status.INACTIVE.getValue());
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.login(testUsername, testPassword);
        });

        assertEquals(ErrorCode.USER_DISABLED.getCode(), exception.getCode());
        verify(userMapper, times(1)).findByUsername(testUsername);
    }

    /**
     * 测试用户登录失败 - 用户已暂停
     */
    @Test
    @DisplayName("测试用户登录失败 - 用户已暂停")
    void testLoginUserSuspended() {
        // Arrange - 设置用户状态为SUSPENDED
        testUser.setStatus(UserEntity.Status.SUSPENDED.getValue());
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            userService.login(testUsername, testPassword);
        });

        assertEquals(ErrorCode.USER_DISABLED.getCode(), exception.getCode());
    }

    /**
     * 测试修改密码成功
     * 验证点：
     * 1. 验证旧密码正确
     * 2. 新密码使用BCrypt加密
     * 3. 数据库更新成功
     */
    @Test
    @DisplayName("测试修改密码成功")
    void testChangePasswordSuccess() {
        // Arrange
        UUID userId = testUser.getId();
        String oldPassword = testPassword;
        String newPassword = "newpassword456";

        // 注意：这里需要spy userService来mock getById和updateById方法
        UserServiceImpl spyUserService = spy(userService);
        doReturn(testUser).when(spyUserService).getById(userId);
        doReturn(true).when(spyUserService).updateById(any(UserEntity.class));

        // Act
        spyUserService.changePassword(userId, oldPassword, newPassword);

        // Assert - 验证密码已更新
        ArgumentCaptor<UserEntity> userCaptor = ArgumentCaptor.forClass(UserEntity.class);
        verify(spyUserService, times(1)).updateById(userCaptor.capture());

        UserEntity updatedUser = userCaptor.getValue();
        assertNotEquals(oldPassword, updatedUser.getPasswordHash());
        assertTrue(BCrypt.checkpw(newPassword, updatedUser.getPasswordHash()));
    }

    /**
     * 测试修改密码失败 - 用户不存在
     */
    @Test
    @DisplayName("测试修改密码失败 - 用户不存在")
    void testChangePasswordUserNotFound() {
        // Arrange
        UUID userId = UUID.randomUUID();
        UserServiceImpl spyUserService = spy(userService);
        doReturn(null).when(spyUserService).getById(userId);

        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            spyUserService.changePassword(userId, testPassword, "newpassword");
        });

        assertEquals(ErrorCode.USER_NOT_FOUND.getCode(), exception.getCode());
    }

    /**
     * 测试修改密码失败 - 旧密码错误
     * 验证点：
     * 1. 旧密码验证失败时抛出BusinessException
     * 2. 错误码为USER_PASSWORD_ERROR
     */
    @Test
    @DisplayName("测试修改密码失败 - 旧密码错误")
    void testChangePasswordOldPasswordError() {
        // Arrange
        UUID userId = testUser.getId();
        String wrongOldPassword = "wrongpassword";
        String newPassword = "newpassword456";

        UserServiceImpl spyUserService = spy(userService);
        doReturn(testUser).when(spyUserService).getById(userId);

        // Act & Assert
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            spyUserService.changePassword(userId, wrongOldPassword, newPassword);
        });

        assertEquals(ErrorCode.USER_PASSWORD_ERROR.getCode(), exception.getCode());

        // 验证没有调用updateById
        verify(spyUserService, never()).updateById(any(UserEntity.class));
    }

    /**
     * 测试根据用户名查询用户
     */
    @Test
    @DisplayName("测试根据用户名查询用户")
    void testFindByUsername() {
        // Arrange
        when(userMapper.findByUsername(testUsername)).thenReturn(Optional.of(testUser));

        // Act
        Optional<UserEntity> result = userService.findByUsername(testUsername);

        // Assert
        assertTrue(result.isPresent());
        assertEquals(testUsername, result.get().getUsername());
        verify(userMapper, times(1)).findByUsername(testUsername);
    }

    /**
     * 测试根据邮箱查询用户
     */
    @Test
    @DisplayName("测试根据邮箱查询用户")
    void testFindByEmail() {
        // Arrange
        when(userMapper.findByEmail(testEmail)).thenReturn(Optional.of(testUser));

        // Act
        Optional<UserEntity> result = userService.findByEmail(testEmail);

        // Assert
        assertTrue(result.isPresent());
        assertEquals(testEmail, result.get().getEmail());
        verify(userMapper, times(1)).findByEmail(testEmail);
    }

    /**
     * 测试根据租户ID和用户名查询用户
     */
    @Test
    @DisplayName("测试根据租户ID和用户名查询用户")
    void testFindByTenantIdAndUsername() {
        // Arrange
        when(userMapper.findByTenantIdAndUsername(testTenantId, testUsername))
                .thenReturn(Optional.of(testUser));

        // Act
        Optional<UserEntity> result = userService.findByTenantIdAndUsername(testTenantId, testUsername);

        // Assert
        assertTrue(result.isPresent());
        assertEquals(testUsername, result.get().getUsername());
        assertEquals(testTenantId, result.get().getTenantId());
        verify(userMapper, times(1)).findByTenantIdAndUsername(testTenantId, testUsername);
    }
}
