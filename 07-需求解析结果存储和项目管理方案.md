# 需求解析结果存储和项目管理方案

## 一、现状分析总结

### 1.1 已有的数据存储结构

**核心表结构**:
- `projects` - 项目基本信息（名称、描述、状态、标签等）
- `app_specs` - 应用规范（包含V2.0意图识别、模板选择、风格选择等字段）
- `generation_tasks` - 生成任务历史记录

**V2.0字段（已在数据库中，但Entity层标记为exist=false）**:
- `intent_type` - 意图类型
- `confidence_score` - 置信度
- `intent_classification_result` - 完整意图识别结果（JSONB）
- `matched_templates` - 匹配的模板列表
- `selected_template_id` - 用户选择的模板
- `selected_style` - 用户选择的风格
- `design_confirmed` - 用户是否确认设计
- `frontend_prototype` - 前端原型代码（JSONB）
- `frontend_prototype_url` - 原型预览URL

### 1.2 已有的页面功能

**✅ 已实现**:
- 项目列表页面 (`/dashboard`)
- 项目详情页面 (`/wizard/[id]`)
- 项目设置页面 (`/settings/[projectId]`)
- 执行历史页面 (`/dashboard/[id]/history`)
- 项��卡片操作菜单（继续编辑、查看结果、设置、历史等）

**⚠️ 部分实现**:
- "继续编辑"按钮存在，但缺少真正的编辑功能
- 没有"修改需求后重新生成"的完整流程

**❌ 缺失功能**:
- 版本历史页面（路由已配置但未实现）
- 版本回滚功能
- 重新生成API接口

---

## 二、用户决策（已确认）

- ✅ **1A - 快照时机**: 每次关键步骤完成时保存快照（用户强调"每次Step完成了就可以保留一次快照和版本"）
- ✅ **2A - 版本管理**: 保留所有版本（无限制）
- ✅ **3A - 意图识别**: 自动重新识别（修改需求后自动调用IntentClassifier）
- ✅ **4A - 生成范围**: 完整重新生成（原型+后端）
- ✅ **5A - V2.0字段**: 立即启用

---

## 三、版本和步骤的关系（核心理解）

### 3.1 核心概念

**重要理解**：
- **版本（Version）**：一次完整的生成流程（从需求输入到Validate完成）= 一个版本
- **步骤（Step）**：版本内部包含多个步骤的状态快照
- **版本创建时机**：只有当用户"重新生成"时，才创建新版本（v1 → v2）

**版本和步骤的层级关系**：
```
版本1（用户首次创建项目）
  ├── 步骤快照1: 需求输入完成
  ├── 步骤快照2: 意图识别完成
  ├── 步骤快照3: 模板匹配完成
  ├── 步骤快照4: 风格选择完成
  ├── 步骤快照5: 原型生成完成
  ├── 步骤快照6: 用户确认设计
  ├── 步骤快照7: Plan完成
  ├── 步骤快照8: Execute完成
  └── 步骤快照9: Validate完成（版本1最终状态）

版本2（用户编辑后重新生成）
  ├── 步骤快照1: 需求输入完成（修改后）
  ├── 步骤快照2: 意图识别完成（重新识别）
  └── ... （重复流程）
```

### 3.2 数据库Schema设计

**利用现有表结构（需要新增代码存储字段）**：

```sql
-- app_specs表（已有字段）
- id UUID                              -- 版本ID
- version INT                          -- 版本号（1, 2, 3...）
- parent_version_id UUID               -- 指向上一版本
- spec_content JSONB                   -- 完整AppSpec内容
- intent_type VARCHAR                  -- 意图类型
- selected_style VARCHAR               -- 选择的风格
- design_confirmed BOOLEAN             -- 用户是否确认设计
- frontend_prototype JSONB             -- 前端原型代码
- created_at TIMESTAMP                 -- 版本创建时间

-- app_specs表（需要新增字段）
- frontend_code_url VARCHAR            -- 前端代码仓库地址（GitHub/GitLab）
- backend_code_url VARCHAR             -- 后端代码仓库地址
- code_archive_path VARCHAR            -- 代码归档路径（本地存储/OSS）
- code_commit_hash VARCHAR             -- 代码提交哈希值

-- generation_tasks表（已有字段）
- id UUID                              -- 任务ID
- app_spec_id UUID                     -- 关联的app_spec版本
- agents_info JSONB                    -- 每个Agent的执行状态（步骤快照）
- plan_result JSONB                    -- Plan Agent结果
- app_spec_content JSONB               -- Execute Agent结果
- validate_result JSONB                -- Validate Agent结果
- status VARCHAR                       -- 任务状态
- progress INT                         -- 进度（0-100）
- current_agent VARCHAR                -- 当前执行的Agent
- started_at TIMESTAMP                 -- 任务开始时间
- completed_at TIMESTAMP               -- 任务完成时间
```

**代码存储字段说明**：
- `frontend_code_url`: 前端代码仓库地址（如 `https://github.com/user/project-frontend-v1`）
- `backend_code_url`: 后端代码仓库地址（如 `https://github.com/user/project-backend-v1`）
- `code_archive_path`: 代码归档路径（如 `/archives/project-123/v1.zip` 或 OSS路径）
- `code_commit_hash`: 代码提交哈希值（用于精确定位代码版本）

**agents_info字段示例（步骤级快照）**：
```json
{
  "plan": {
    "status": "completed",
    "startedAt": "2026-01-25T10:00:00Z",
    "completedAt": "2026-01-25T10:02:00Z",
    "result": { ... }
  },
  "execute": {
    "status": "completed",
    "startedAt": "2026-01-25T10:02:00Z",
    "completedAt": "2026-01-25T10:10:00Z",
    "result": { ... }
  },
  "validate": {
    "status": "completed",
    "startedAt": "2026-01-25T10:10:00Z",
    "completedAt": "2026-01-25T10:12:00Z",
    "result": { ... }
  }
}
```

### 3.3 版本链示例

```
项目创建流程的版本链：

版本1（首次创建）
  ├── app_spec_id: uuid-v1
  ├── version: 1
  ├── parent_version_id: null
  └── generation_task_id: task-1
      └── agents_info: { plan: {...}, execute: {...}, validate: {...} }
      └── 步骤快照记录在agents_info中

版本2（用户编辑后重新生成）
  ├── app_spec_id: uuid-v2
  ├── version: 2
  ├── parent_version_id: uuid-v1  ← 指向版本1
  └── generation_task_id: task-2
      └── agents_info: { plan: {...}, execute: {...}, validate: {...} }
      └── 步骤快照记录在agents_info中

版本3（再次编辑）
  ├── app_spec_id: uuid-v3
  ├── version: 3
  ├── parent_version_id: uuid-v2  ← 指向版本2
  └── generation_task_id: task-3
      └── agents_info: { plan: {...}, execute: {...}, validate: {...} }
```

**关键理解**：
- `app_specs.version`表示"重新生成的版本号"（1, 2, 3...）
- `generation_tasks.agents_info`记录版本内部的步骤快照
- 用户查看"版本历史"时，展示的是`app_specs`的版本列表
- 用户查看"执行历史"时，展示的是`generation_tasks`的步骤列表

---

## 四、详细实施计划

### Phase 1: 数据库迁移和代码存储字段（2小时）

**前置依赖**: 无

**实施内容**:
1. 创建数据库迁移脚本（添加代码存储字段）
2. 修改AppSpecEntity.java（将V2.0字段的exist改为true，添加代码存储字段）
3. 验证V2.0字段和代码存储字段可以正常读写
4. 单元测试

**验收标准**:
- [ ] 数据库迁移脚本执行成功
- [ ] frontend_code_url、backend_code_url、code_archive_path、code_commit_hash字段已添加
- [ ] AppSpecEntity可以正常读写V2.0字段和代码存储字段
- [ ] 单元测试通过
- [ ] 现有功能不受影响

**产出物**:
- `backend/migrations/021_add_code_storage_fields_to_app_specs.sql`（新增）
- `backend/src/main/java/com/ingenio/backend/entity/AppSpecEntity.java`（修改）

**数据库迁移脚本**:
```sql
-- 021_add_code_storage_fields_to_app_specs.sql
ALTER TABLE app_specs ADD COLUMN frontend_code_url VARCHAR(500);
ALTER TABLE app_specs ADD COLUMN backend_code_url VARCHAR(500);
ALTER TABLE app_specs ADD COLUMN code_archive_path VARCHAR(500);
ALTER TABLE app_specs ADD COLUMN code_commit_hash VARCHAR(100);

-- 添加注释
COMMENT ON COLUMN app_specs.frontend_code_url IS '前端代码仓库地址（GitHub/GitLab）';
COMMENT ON COLUMN app_specs.backend_code_url IS '后端代码仓库地址';
COMMENT ON COLUMN app_specs.code_archive_path IS '代码归档路径（本地存储/OSS）';
COMMENT ON COLUMN app_specs.code_commit_hash IS '代码提交哈希值';

-- 创建索引
CREATE INDEX idx_app_specs_code_commit_hash ON app_specs(code_commit_hash);
```

**Entity修改**:
```java
// AppSpecEntity.java
@TableField(value = "intent_type", exist = true)
private String intentType;

@TableField(value = "confidence_score", exist = true)
private BigDecimal confidenceScore;

@TableField(value = "selected_style", exist = true)
private String selectedStyle;

// 新增代码存储字段
@TableField(value = "frontend_code_url", exist = true)
private String frontendCodeUrl;

@TableField(value = "backend_code_url", exist = true)
private String backendCodeUrl;

@TableField(value = "code_archive_path", exist = true)
private String codeArchivePath;

@TableField(value = "code_commit_hash", exist = true)
private String codeCommitHash;
```

---

### Phase 2: 代码持久化服务实现（3小时）

**前置依赖**: Phase 1完成

**实施内容**:
1. 实现CodeStorageService（代码存储服务）
2. 集成Git仓库管理（创建仓库、提交代码、获取commit hash）
3. 集成代码归档（ZIP压缩、上传到OSS/本地存储）
4. 在Execute Agent完成后自动保存代码
5. 单元测试

**验收标准**:
- [ ] 代码生成完成后自动创建Git仓库
- [ ] 代码自动提交到Git仓库并获取commit hash
- [ ] 代码自动归档为ZIP文件
- [ ] frontend_code_url、backend_code_url、code_archive_path、code_commit_hash正确保存
- [ ] 单元测试覆盖率≥85%

**产出物**:
- `backend/src/main/java/com/ingenio/backend/service/CodeStorageService.java`（新增）
- `backend/src/main/java/com/ingenio/backend/service/impl/CodeStorageServiceImpl.java`（新增）
- `backend/src/test/java/com/ingenio/backend/service/CodeStorageServiceTest.java`（新增）

**CodeStorageService接口设计**:
```java
public interface CodeStorageService {
    /**
     * 保存生成的代码
     * @param appSpecId AppSpec ID
     * @param frontendCode 前端代码（文件路径或内容）
     * @param backendCode 后端代码（文件路径或内容）
     * @return 代码存储结果
     */
    CodeStorageResult saveGeneratedCode(UUID appSpecId, String frontendCode, String backendCode);

    /**
     * 获取代码
     * @param appSpecId AppSpec ID
     * @return 代码内容或下载URL
     */
    CodeRetrievalResult getCode(UUID appSpecId);

    /**
     * 创建Git仓库并提交代码
     * @param projectName 项目名称
     * @param code 代码内容
     * @return Git仓库URL和commit hash
     */
    GitRepositoryResult createGitRepository(String projectName, String code);

    /**
     * 归档代码为ZIP文件
     * @param appSpecId AppSpec ID
     * @param code 代码内容
     * @return 归档文件路径
     */
    String archiveCode(UUID appSpecId, String code);
}
```

**代码存储流程**:
```
Execute Agent完成
  ↓
调用CodeStorageService.saveGeneratedCode()
  ↓
1. 创建前端Git仓库
   - 初始化Git仓库
   - 提交代码
   - 获取commit hash
   - 推送到远程（GitHub/GitLab）
  ↓
2. 创建后端Git仓库
   - 初始化Git仓库
   - 提交代码
   - 获取commit hash
   - 推送到远程
  ↓
3. 归档代码
   - 压缩前端代码为ZIP
   - 压缩后端代码为ZIP
   - 上传到OSS/本地存储
  ↓
4. 更新app_specs表
   - frontend_code_url = Git仓库URL
   - backend_code_url = Git仓库URL
   - code_archive_path = ZIP文件路径
   - code_commit_hash = commit hash
```

---

### Phase 3: 编辑和重新生成功能（4小时）

**前置依赖**: Phase 1完成

**实施内容**:
1. 实现编辑页面 `/projects/[id]/edit`
2. 实现更新需求API `PUT /v1/projects/{id}/requirement`
3. 实现重新生成API `POST /v1/projects/{id}/regenerate`
4. 集成意图识别（自动重新识别）
5. 集成完整重新生成（原型+后端）

**验收标准**:
- [ ] 编辑页面可以展示当前需求、意图、模板、风格
- [ ] 用户可以修改需求描述
- [ ] 点击"重新分析"自动调用IntentClassifier
- [ ] 点击"重新生成"创建新的generation_task
- [ ] 创建新版本的app_spec（version+1）
- [ ] 跳转到生成进度页面

**产出物**:
- `frontend/src/app/projects/[id]/edit/page.tsx`（新增）
- `backend/src/main/java/com/ingenio/backend/controller/ProjectController.java`（新增API）
- `frontend/src/lib/api/projects.ts`（新增API调用）

**API设计**:
```typescript
// PUT /v1/projects/{id}/requirement
interface UpdateRequirementRequest {
  description: string;
  reanalyzeIntent: boolean; // 是否重新识别意图（默认true）
}

interface UpdateRequirementResponse {
  projectId: string;
  intentClassificationResult?: IntentClassificationResult;
}

// POST /v1/projects/{id}/regenerate
interface RegenerateRequest {
  selectedTemplateId?: string;
  selectedStyle: string;
  regeneratePrototype: boolean; // 是否重新生成原型（默认true）
}

interface RegenerateResponse {
  projectId: string;
  taskId: string;
  newVersionId: string;
  newVersion: number;
}
```

**编辑页面流程**:
```
用户点击"继续编辑"
  ↓
进入编辑页面 /projects/[id]/edit
  ↓
展示当前需求、意图、模板、风格
  ↓
用户修改需求描述
  ↓
点击"重新分析"按钮
  ↓
调用PUT /v1/projects/{id}/requirement（自动重新识别意图）
  ↓
用户确认或修改模板/风格选择
  ↓
点击"重新生成"按钮
  ↓
调用POST /v1/projects/{id}/regenerate
  ↓
创建新的generation_task
  ↓
创建新版本的app_spec（version+1, parent_version_id指向当前版本）
  ↓
跳转到生成进度页面 /wizard/[id]
```

---

### Phase 3: 版本历史和回滚功能（3小时）

**前置依赖**: Phase 2完成

**实施内容**:
1. 实现版本历史页面 `/versions/[appId]`
2. 实现版本历史API `GET /v1/projects/{id}/versions`
3. 实现版本回滚API `POST /v1/projects/{id}/versions/{versionId}/rollback`
4. 版本时间线展示（UI组件）

**验收标准**:
- [ ] 版本历史页面展示所有版本（时间线形式）
- [ ] 每个版本显示版本号、需求描述、创建时间
- [ ] 点击"查看详情"跳转到版本详情页
- [ ] 点击"回滚到此版本"创建新版本（基于选中版本）
- [ ] 回滚后跳转到编辑页面

**产出物**:
- `frontend/src/app/versions/[appId]/page.tsx`（实现）
- `frontend/src/components/VersionTimeline.tsx`（新增）
- `backend/src/main/java/com/ingenio/backend/controller/ProjectController.java`（新增API）

**API设计**:
```typescript
// GET /v1/projects/{id}/versions
interface VersionHistoryResponse {
  versions: Array<{
    versionId: string;
    version: number;
    description: string;
    intentType?: string;
    selectedStyle?: string;
    createdAt: string;
    parentVersionId?: string;
    taskId?: string;  // 关联的generation_task
  }>;
}

// POST /v1/projects/{id}/versions/{versionId}/rollback
interface RollbackResponse {
  projectId: string;
  newVersionId: string;
  newVersion: number;
  rolledBackFromVersion: number;
}
```

---

### Phase 4: 集成测试和优化（2小时）

**前置依赖**: Phase 3完成

**实施内容**:
1. E2E测试（编辑→重新生成→版本历史→回滚）
2. 性能优化（JSONB查询、版本列表分页）
3. 用户体验优化（加载状态、错误提示、确认对话框）
4. 文档更新

**验收标准**:
- [ ] E2E测试通过
- [ ] 版本列表查询性能<100ms
- [ ] 用户体验流畅（加载动画、错误提示清晰）
- [ ] API文档已更新

**产出物**:
- `frontend/tests/e2e/project-edit-regenerate.spec.ts`（新增）
- `docs/api/version-management-api.md`（新增）

---

## 五、关键文件路径

### 后端
- **Entity**: `backend/src/main/java/com/ingenio/backend/entity/AppSpecEntity.java`（修改）
- **Controller**: `backend/src/main/java/com/ingenio/backend/controller/ProjectController.java`（修改）
- **Service**: `backend/src/main/java/com/ingenio/backend/service/ProjectService.java`（修改）

### 前端
- **编辑页面**: `frontend/src/app/projects/[id]/edit/page.tsx`（新增）
- **版本历史**: `frontend/src/app/versions/[appId]/page.tsx`（实现）
- **版本时间线**: `frontend/src/components/VersionTimeline.tsx`（新增）
- **API客户端**: `frontend/src/lib/api/projects.ts`（修改）
- **类型定义**: `frontend/src/types/project.ts`（修改）

---

## 六、验证计划

### 端到端验证流程
1. 创建新项目 → 验证generation_tasks记录了步骤快照
2. 查看版本历史 → 验证版本链完整
3. 编辑需求 → 验证自动重新识别意图
4. 重新生成 → 验证完整重新生成（原型+后端）
5. 回滚版本 → 验证回滚到指定版本
6. 查看版本详情 → 验证数据完整性

### 性能验证
- 版本列表查询 < 100ms
- 版本回滚 < 200ms

### 数据完整性验证
- 所有版本的parent_version_id正确
- 版本链无断裂
- JSONB字段数据完整
- generation_tasks的agents_info记录完整

---

## 七、风险评估

| 风险 | 影响 | 概率 | 应对措施 |
|-----|------|------|---------|
| 版本链断裂 | 高 | 低 | 事务保证、完善错误处理、添加数据一致性检查 |
| 意图识别API超时 | 中 | 中 | 设置30秒超时、提供"跳过重新识别"选项 |
| 前端状态管理复杂 | 中 | 中 | 使用Zustand统一管理版本状态 |
| generation_tasks数据过大 | 中 | 低 | 添加分页、定期归档旧任务 |

---

## 八、后续优化方向

1. **版本对比功能**: 对比两个版本的差异（需求、意图、模板、风格）
2. **版本标签**: 用户可以为重要版本添加标签（如"v1.0发布版"）
3. **版本分支**: 支持从某个版本创建分支，进行并行开发
4. **自动归档**: 定期归档超过N天的旧版本（软删除）
5. **版本导出**: 导出版本历史为JSON文件
