# AI代码生成器最佳实践指南

> **文档版本**: v1.0.0
> **创建日期**: 2025-11-11
> **作者**: Ingenio Team
> **状态**: 正式版

---

## 目录

- [1. 如何添加新的AI能力类型](#1-如何添加新的ai能力类型)
- [2. 如何优化代码生成性能](#2-如何优化代码生成性能)
- [3. 如何处理AI模型调用失败](#3-如何处理ai模型调用失败)
- [4. 如何测试AI能力集成](#4-如何测试ai能力集成)
- [5. 如何调试代码生成问题](#5-如何调试代码生成问题)
- [6. 如何管理API成本](#6-如何管理api成本)
- [7. 如何保证生成代码质量](#7-如何保证生成代码质量)

---

## 1. 如何添加新的AI能力类型

### 1.1 七步标准流程

#### Step 1: 需求调研（1天）

**调研清单**：
- [ ] 市场需求分析（目标用户、使用场景）
- [ ] 技术可行性评估（AI模型选型、API可用性）
- [ ] 竞品分析（3家以上竞品对比）
- [ ] 成本估算（API调用成本、开发成本）
- [ ] 风险评估（技术风险、业务风险）

**输出文档**：
```markdown
# 新AI能力需求文档

## 1. 需求概述
- AI能力名称：智能视频剪辑
- 英文标识符：VIDEO_EDITING
- 复杂度等级：COMPLEX
- 目标用户：短视频创作者、营销团队

## 2. 使用场景
1. 自动识别精彩片段
2. 智能添加背景音乐
3. 自动生成字幕
4. 一键生成多个版本

## 3. 技术方案
- AI模型：Qwen-VL-Max + FFmpeg
- API端点：https://dashscope.aliyuncs.com/...
- 预估成本：¥0.05/次

## 4. 开发计划
- 开发时间：7天
- 测试时间：3天
- 上线时间：2025-11-20
```

#### Step 2: 后端代码生成方法实现（2天）

**文件路径**：`backend/src/main/java/com/ingenio/backend/service/AICodeGenerator.java`

```java
/**
 * 生成视频剪辑代码
 *
 * AI能力：VIDEO_EDITING
 * 复杂度：COMPLEX
 * 技术实现：Qwen-VL-Max + FFmpeg
 */
private Map<String, String> generateVideoEditingCode(
    String packageName,
    String appName
) {
    Map<String, String> files = new HashMap<>();
    String packagePath = packageNameToPath(packageName);
    String generationDate = LocalDateTime.now().format(DATE_FORMATTER);

    // 1. VideoEditingService.kt - AI服务
    String serviceContent = String.format("""
        package %s.ai

        import io.ktor.client.*
        import kotlinx.serialization.Serializable

        /**
         * 视频剪辑AI服务
         * 基于阿里云通义千问Qwen-VL-Max实现
         *
         * Generated by Ingenio Platform
         * Date: %s
         */
        class VideoEditingService(
            private val apiKey: String
        ) {
            /**
             * 自动剪辑视频
             */
            suspend fun autoEdit(
                videoUrl: String,
                editStyle: EditStyle
            ): EditResult {
                // 调用Qwen-VL-Max API
                // ...
            }
        }

        enum class EditStyle {
            HIGHLIGHTS,  // 精彩片段
            TRAILER,     // 预告片
            SOCIAL       // 社交媒体
        }

        @Serializable
        data class EditResult(
            val outputUrl: String,
            val duration: Int,
            val segments: List<Segment>
        )
        """, packageName, generationDate);

    files.put("core/src/commonMain/kotlin/" + packagePath + "/ai/VideoEditingService.kt", serviceContent);

    // 2. VideoEditingViewModel.kt - ViewModel
    // ... (省略具体实现)

    // 3. README_VIDEO_EDITING.md - 使用文档
    // ... (省略具体实现)

    log.info("生成VIDEO_EDITING代码: {} 个文件", files.size());
    return files;
}
```

**添加到switch语句**：

```java
private Map<String, String> generateCapabilitySpecificCode(
    AICapabilityRequirement.AICapabilityType capabilityType,
    String packageName,
    String appName
) {
    switch (capabilityType) {
        case VIDEO_ANALYSIS:
            return generateVideoAnalysisCode(packageName, appName);
        case KNOWLEDGE_GRAPH:
            return generateKnowledgeGraphCode(packageName, appName);
        // ... 其他能力
        case VIDEO_EDITING:  // 新增
            return generateVideoEditingCode(packageName, appName);
        default:
            return new HashMap<>();
    }
}
```

#### Step 3: 前端类型定义（0.5天）

**文件路径**：`frontend/src/types/ai-capability.ts`

```typescript
export enum AICapabilityType {
  CHATBOT = 'CHATBOT',
  VIDEO_ANALYSIS = 'VIDEO_ANALYSIS',
  // ... 其他能力
  VIDEO_EDITING = 'VIDEO_EDITING', // 新增
}
```

#### Step 4: 前端数据添加（0.5天）

**文件路径**：`frontend/src/data/ai-capabilities.ts`

```typescript
export const AI_CAPABILITIES: AICapability[] = [
  // ... 现有能力
  {
    type: AICapabilityType.VIDEO_EDITING,
    name: '智能视频剪辑',
    nameEn: 'Video Editing',
    description: '自动识别精彩片段，智能剪辑视频',
    detailedDescription: '基于AI的智能视频剪辑系统，支持精彩片段识别、自动配乐、字幕生成、多版本输出等功能。适用于短视频创作、营销内容制作等场景。',
    icon: 'Film',
    complexity: ComplexityLevel.COMPLEX,
    estimatedCost: 50.0,
    category: AICapabilityCategory.VISION,
    useCases: ['短视频创作', '营销视频制作', '教育视频剪辑', '企业宣传片'],
    techStack: ['Qwen-VL-Max', 'FFmpeg', 'Ktor', 'MinIO'],
    estimatedDays: 7,
    isNew: true,
  },
];
```

#### Step 5: 后端DTO更新（0.5天）

**文件路径**：`backend/src/main/java/com/ingenio/backend/agent/dto/AICapabilityRequirement.java`

```java
public enum AICapabilityType {
    CHATBOT,
    VIDEO_ANALYSIS,
    // ... 其他能力
    VIDEO_EDITING,  // 新增
}
```

#### Step 6: 测试验证（2天）

**单元测试**（`AICodeGeneratorTest.java`）：

```java
@Test
@DisplayName("生成VIDEO_EDITING代码 - 成功场景")
public void testGenerateVideoEditingCode_Success() {
    // 准备测试数据
    AICapabilityRequirement requirement = new AICapabilityRequirement();
    requirement.setNeedsAI(true);
    requirement.setComplexity(AIComplexity.COMPLEX);

    AICapabilityRequirement.AICapability capability =
        new AICapabilityRequirement.AICapability();
    capability.setType(AICapabilityType.VIDEO_EDITING);
    requirement.setCapabilities(List.of(capability));

    // 执行生成
    Map<String, String> files = aiCodeGenerator.generateAICode(
        requirement,
        "com.example.myapp",
        "MyApp"
    );

    // 验证结果
    assertNotNull(files);
    assertTrue(files.size() >= 3, "至少生成3个文件");
    assertTrue(files.containsKey("core/src/commonMain/kotlin/com/example/myapp/ai/VideoEditingService.kt"));
    assertTrue(files.containsKey("core/src/commonMain/kotlin/com/example/myapp/presentation/viewmodel/VideoEditingViewModel.kt"));
    assertTrue(files.containsKey("core/src/commonMain/kotlin/com/example/myapp/ai/README_VIDEO_EDITING.md"));

    // 验证文件内容
    String serviceContent = files.get("core/src/commonMain/kotlin/com/example/myapp/ai/VideoEditingService.kt");
    assertTrue(serviceContent.contains("VideoEditingService"));
    assertTrue(serviceContent.contains("autoEdit"));
}
```

**E2E测试**（`AICodeGeneratorE2ETest.java`）：

```java
@Test
@DisplayName("完整流程测试 - VIDEO_EDITING代码生成")
public void testVideoEditingE2E() throws Exception {
    String requestJson = """
        {
            "packageName": "com.example.videoeditor",
            "appName": "VideoEditor",
            "capabilities": ["VIDEO_EDITING"],
            "userRequirement": "构建智能视频剪辑应用"
        }
        """;

    mockMvc.perform(post("/api/v1/ai-code/generate")
            .contentType(MediaType.APPLICATION_JSON)
            .content(requestJson))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.fileCount").value(greaterThanOrEqualTo(3)));
}
```

#### Step 7: 文档更新（0.5天）

**更新文档**：
1. `backend/docs/design/AI_CAPABILITIES_QUICK_REFERENCE.md` - 添加新能力简介
2. `frontend/README.md` - 更新AI能力列表
3. `CHANGELOG.md` - 记录版本变更

**Commit Message示例**：
```bash
feat: 新增VIDEO_EDITING（智能视频剪辑）AI能力类型

实现内容：
- 后端：VideoEditingService代码生成方法
- 前端：AI能力数据和类型定义
- 测试：单元测试和E2E测试覆盖率100%

技术实现：
- AI模型：Qwen-VL-Max
- 复杂度：COMPLEX
- 预估成本：¥0.05/次

Generated with Claude Code
Co-Authored-By: Claude <noreply@anthropic.com>
```

---

## 2. 如何优化代码生成性能

### 2.1 十条黄金法则

#### 法则1：使用请求缓存

**问题**：重复生成相同代码，浪费API调用和时间

**解决方案**：基于请求参数的缓存策略

```java
@Cacheable(value = "aiCodeCache",
           key = "#request.packageName + '_' + #request.capabilities.toString()",
           unless = "#result == null")
public GenerateAICodeResponse generateCode(GenerateAICodeRequest request) {
    // 生成代码逻辑
}
```

**效果**：
- 缓存命中率：~40-60%
- 响应时间：缓存命中<10ms，未命中~1500ms
- 成本节省：~30-40%

#### 法则2：并行生成多个文件

**问题**：串行生成多个文件，耗时长

**解决方案**：使用CompletableFuture并行生成

```java
List<CompletableFuture<String>> futures = List.of(
    CompletableFuture.supplyAsync(() -> generateServiceCode()),
    CompletableFuture.supplyAsync(() -> generateViewModelCode()),
    CompletableFuture.supplyAsync(() -> generateReadmeCode())
);

CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

Map<String, String> files = new HashMap<>();
files.put("Service.kt", futures.get(0).join());
files.put("ViewModel.kt", futures.get(1).join());
files.put("README.md", futures.get(2).join());
```

**效果**：
- 生成速度提升：3-5倍
- 适用场景：多AI能力类型同时生成

#### 法则3：优化模板加载

**问题**：每次生成都从classpath加载模板文件

**解决方案**：启动时预加载模板到内存

```java
@Component
public class TemplateCache {
    private final Map<String, String> templates = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        log.info("预加载代码模板...");
        templates.put("AIServicePager.kt", loadTemplate("templates/ai/kuikly/AIServicePager.kt.template"));
        templates.put("AIService.kt", loadTemplate("templates/ai/kuikly/AIService.kt.template"));
        // ... 其他模板
        log.info("预加载完成: {} 个模板", templates.size());
    }

    public String getTemplate(String name) {
        return templates.get(name);
    }
}
```

**效果**：
- 模板加载时间：~50ms → ~0.1ms
- 减少IO操作

#### 法则4：批量生成优化

**问题**：多个用户同时生成，服务器压力大

**解决方案**：请求队列+批量处理

```java
@Service
public class BatchGeneratorService {
    private final BlockingQueue<GenerateTask> queue = new LinkedBlockingQueue<>(100);

    @Scheduled(fixedRate = 5000) // 每5秒批量处理一次
    public void processBatch() {
        List<GenerateTask> tasks = new ArrayList<>();
        queue.drainTo(tasks, 10); // 每批最多10个

        if (tasks.isEmpty()) return;

        log.info("批量处理 {} 个代码生成任务", tasks.size());

        tasks.parallelStream().forEach(task -> {
            try {
                task.complete(generateCode(task.getRequest()));
            } catch (Exception e) {
                task.completeExceptionally(e);
            }
        });
    }
}
```

**效果**：
- 提升吞吐量：~50%
- 降低瞬时压力

#### 法则5：使用流式响应

**问题**：用户等待时间长，体验差

**解决方案**：WebSocket实时推送生成进度

```java
@MessageMapping("/generate")
@SendTo("/topic/progress")
public Flux<GenerateProgress> generateWithProgress(GenerateRequest request) {
    return Flux.create(sink -> {
        sink.next(new GenerateProgress("开始生成...", 0));
        sink.next(new GenerateProgress("生成Service代码...", 33));
        sink.next(new GenerateProgress("生成ViewModel代码...", 66));
        sink.next(new GenerateProgress("生成完成!", 100));
        sink.complete();
    });
}
```

**效果**：
- 用户体验提升：可实时看到进度
- 减少用户焦虑

#### 法则6：压缩生成的ZIP文件

**问题**：生成的ZIP文件过大，下载慢

**解决方案**：使用GZIP最高压缩级别

```java
ZipOutputStream zos = new ZipOutputStream(
    new BufferedOutputStream(new FileOutputStream(zipFile))
);
zos.setLevel(Deflater.BEST_COMPRESSION); // 最高压缩级别
```

**效果**：
- 文件大小减少：~60-80%
- 下载时间减少：~70%

#### 法则7：使用CDN加速静态资源

**问题**：生成的ZIP文件下载慢

**解决方案**：上传到CDN（如阿里云OSS + CDN）

```java
@Service
public class CDNUploadService {
    public String uploadToCDN(File file) {
        // 上传到OSS
        String ossUrl = ossClient.upload(file);

        // 返回CDN URL
        return ossUrl.replace("oss-cn-beijing.aliyuncs.com",
                              "cdn.ingenio.dev");
    }
}
```

**效果**：
- 下载速度提升：3-10倍
- 全球加速：多节点分发

#### 法则8：异步生成+通知

**问题**：用户等待时间长（>10秒）

**解决方案**：异步生成，完成后邮件/短信通知

```java
@Async
public CompletableFuture<GenerateResult> generateAsync(GenerateRequest request) {
    GenerateResult result = generateCode(request);

    // 发送邮件通知
    emailService.sendGenerationCompleteEmail(
        request.getUserEmail(),
        result.getDownloadUrl()
    );

    return CompletableFuture.completedFuture(result);
}
```

**效果**：
- 用户可以先关闭页面，稍后下载
- 适合大型项目生成（>1分钟）

#### 法则9：代码模板优化

**问题**：生成的代码冗余，文件大

**解决方案**：精简模板，删除不必要的注释和空行

```kotlin
// ❌ 冗余模板
/**
 * This is a service class for AI functionality
 * It provides methods to interact with AI models
 * Generated by Ingenio Platform
 * Date: 2025-11-11 14:30:00
 * Author: System
 * Version: 1.0.0
 */
class AIService {
    // ... 20行注释
}

// ✅ 精简模板
/**
 * AI服务类
 * Generated by Ingenio Platform
 */
class AIService {
    // ...
}
```

**效果**：
- 文件大小减少：~20-30%
- 可读性提升

#### 法则10：数据库查询优化

**问题**：查询历史生成记录慢

**解决方案**：添加索引+分页查询

```sql
-- 添加复合索引
CREATE INDEX idx_user_created ON generated_files(user_id, created_at DESC);

-- 分页查询
SELECT * FROM generated_files
WHERE user_id = #{userId}
ORDER BY created_at DESC
LIMIT #{pageSize} OFFSET #{offset};
```

**效果**：
- 查询速度提升：10-100倍
- 支持大数据量（>100万条记录）

---

## 3. 如何处理AI模型调用失败

### 3.1 五层降级策略

#### 层级1：请求重试（Retry）

```java
@Retryable(
    value = {ApiException.class, TimeoutException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2)
)
public AIResponse callAI(AIRequest request) {
    // 调用AI API
}
```

**适用场景**：
- 网络抖动
- 临时故障
- 超时错误

#### 层级2：备用模型（Fallback Model）

```java
public AIResponse callAIWithFallback(AIRequest request) {
    try {
        return qwenClient.generate(request);
    } catch (Exception e) {
        log.warn("Qwen调用失败，切换到Gemini: {}", e.getMessage());
        return geminiClient.generate(request);
    }
}
```

**模型优先级**：
1. Qwen-Max（首选，性价比高）
2. Gemini 2.0 Flash（备选，速度快）
3. GPT-4o-mini（最后，成本高）

#### 层级3：缓存降级（Cache Fallback）

```java
public AIResponse callAIWithCache(AIRequest request) {
    try {
        return qwenClient.generate(request);
    } catch (Exception e) {
        log.warn("API调用失败，返回缓存结果");
        return cacheService.getSimilarResult(request);
    }
}
```

**缓存策略**：
- 基于请求相似度匹配（余弦相似度>0.9）
- 返回最近24小时内的结果
- 添加"缓存结果"标识

#### 层级4：通用模板降级（Generic Template）

```java
public GenerateResult generateWithFallback(GenerateRequest request) {
    try {
        return aiGenerator.generate(request);
    } catch (Exception e) {
        log.warn("AI生成失败，使用通用模板");
        return genericTemplateGenerator.generate(request);
    }
}
```

**通用模板特点**：
- 不依赖AI API
- 基于预定义模板
- 功能完整但不个性化

#### 层级5：人工介入（Manual Intervention）

```java
public GenerateResult generateWithManualFallback(GenerateRequest request) {
    try {
        return aiGenerator.generate(request);
    } catch (Exception e) {
        log.error("所有自动化方案失败，转人工处理");

        // 创建人工工单
        Ticket ticket = ticketService.createTicket(
            "AI代码生成失败",
            request,
            e.getMessage()
        );

        // 发送邮件通知用户
        emailService.sendManualProcessingEmail(
            request.getUserEmail(),
            ticket.getId()
        );

        throw new ManualInterventionRequiredException(ticket.getId());
    }
}
```

**人工处理流程**：
1. 创建工单（优先级：HIGH）
2. 邮件通知用户（预计处理时间：24小时）
3. 工程师手动生成代码
4. 完成后通知用户

### 3.2 熔断器模式（Circuit Breaker）

```java
@CircuitBreaker(
    name = "qwenAPI",
    fallbackMethod = "generateWithFallback"
)
public AIResponse callQwen(AIRequest request) {
    return qwenClient.generate(request);
}

public AIResponse generateWithFallback(AIRequest request, Throwable ex) {
    log.warn("熔断器打开，切换到备用方案: {}", ex.getMessage());
    return geminiClient.generate(request);
}
```

**熔断策略**：
- 失败率阈值：50%
- 请求数阈值：10次
- 熔断时长：30秒
- 半开状态：允许3次尝试

---

## 4. 如何测试AI能力集成

### 4.1 测试金字塔

```
         /\
        /E2E\       (10%)  - 端到端测试
       /------\
      /集成测试\    (30%)  - API集成测试
     /----------\
    /  单元测试  \  (60%)  - 单元测试
   /--------------\
```

### 4.2 单元测试清单

```java
// 1. 参数验证测试
@Test
@DisplayName("参数验证 - 包名为空")
public void testValidation_PackageNameEmpty() {
    assertThrows(BusinessException.class, () ->
        aiCodeGenerator.generateAICode(null, "", "MyApp")
    );
}

// 2. 代码生成测试
@Test
@DisplayName("代码生成 - VIDEO_ANALYSIS")
public void testGenerate_VideoAnalysis() {
    Map<String, String> files = aiCodeGenerator.generateAICode(
        createVideoAnalysisRequirement(),
        "com.example.myapp",
        "MyApp"
    );

    assertEquals(3, files.size());
    assertTrue(files.containsKey("VideoAnalysisService.kt"));
}

// 3. 异常处理测试
@Test
@DisplayName("异常处理 - API调用失败")
public void testErrorHandling_APIFailure() {
    when(qwenClient.generate(any())).thenThrow(new ApiException("API Error"));

    assertThrows(BusinessException.class, () ->
        aiCodeGenerator.generateAICode(...)
    );
}
```

### 4.3 E2E测试清单

```java
@SpringBootTest(webEnvironment = RANDOM_PORT)
@Testcontainers
public class AICodeGeneratorE2ETest {
    @Test
    @DisplayName("完整流程 - 从请求到下载")
    public void testFullFlow() throws Exception {
        // 1. 发送生成请求
        String response = mockMvc.perform(post("/api/v1/ai-code/generate")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestJson))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();

        // 2. 解析响应
        GenerateResponse result = objectMapper.readValue(response, GenerateResponse.class);
        assertNotNull(result.getTaskId());

        // 3. 查询生成状态
        mockMvc.perform(get("/api/v1/ai-code/status/" + result.getTaskId()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("COMPLETED"));

        // 4. 下载ZIP文件
        byte[] zipData = mockMvc.perform(get("/api/v1/ai-code/download/" + result.getTaskId()))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsByteArray();

        assertTrue(zipData.length > 0);
    }
}
```

---

## 5. 如何调试代码生成问题

### 5.1 五步排查法

#### Step 1: 检查日志

```bash
# 查看生成日志
tail -f logs/ingenio.log | grep "AICodeGenerator"

# 过滤ERROR级别
tail -f logs/ingenio.log | grep "ERROR"

# 查看特定用户的日志
tail -f logs/ingenio.log | grep "userId=12345"
```

#### Step 2: 验证请求参数

```java
@Slf4j
public class AICodeGeneratorServiceImpl {
    public GenerateResult generate(GenerateRequest request) {
        log.debug("请求参数: {}", JsonUtil.toJson(request));

        // 参数验证
        if (request.getPackageName() == null) {
            log.error("包名为空: request={}", request);
            throw new BusinessException("包名不能为空");
        }

        // ... 生成逻辑
    }
}
```

#### Step 3: 检查AI API响应

```java
public AIResponse callAI(AIRequest request) {
    log.info("调用AI API: model={}, prompt={}", request.getModel(), request.getPrompt());

    AIResponse response = qwenClient.generate(request);

    log.info("AI API响应: status={}, tokens={}, content={}",
             response.getStatus(),
             response.getTokens(),
             response.getContent().substring(0, 100) + "...");

    return response;
}
```

#### Step 4: 验证生成的代码

```java
@Test
public void testGeneratedCode() throws Exception {
    Map<String, String> files = aiCodeGenerator.generate(...);

    // 验证文件数量
    assertEquals(3, files.size());

    // 验证文件内容
    String serviceCode = files.get("Service.kt");
    assertTrue(serviceCode.contains("class VideoAnalysisService"));
    assertTrue(serviceCode.contains("suspend fun analyzeVideo"));

    // 编译验证（可选）
    KotlinCompiler compiler = new KotlinCompiler();
    compiler.compile(serviceCode); // 确保代码可编译
}
```

#### Step 5: 使用调试工具

```java
// IntelliJ IDEA调试技巧
public GenerateResult generate(GenerateRequest request) {
    // 设置断点
    String serviceCode = generateServiceCode(request);  // <- 断点1

    // 条件断点
    if (request.getCapabilities().contains("VIDEO_ANALYSIS")) {
        log.debug("生成VIDEO_ANALYSIS代码");  // <- 条件断点
    }

    // 计算表达式
    // 在调试时，右键 -> Evaluate Expression
    // 输入: files.keySet()
    // 查看所有文件名

    return new GenerateResult(files);
}
```

---

## 6. 如何管理API成本

### 6.1 成本监控仪表盘

```java
@Service
public class CostMonitoringService {
    @Scheduled(cron = "0 0 * * * *") // 每小时执行
    public void calculateHourlyCost() {
        // 统计过去1小时的API调用
        List<APICall> calls = apiCallRepository.findByTimestampAfter(
            LocalDateTime.now().minusHours(1)
        );

        // 计算成本
        double totalCost = calls.stream()
            .mapToDouble(call -> calculateCost(call))
            .sum();

        // 记录成本
        costRepository.save(new CostRecord(
            LocalDateTime.now(),
            totalCost,
            calls.size()
        ));

        // 告警（成本超过阈值）
        if (totalCost > 100.0) {
            alertService.sendCostAlert("小时成本超过$100: " + totalCost);
        }
    }

    private double calculateCost(APICall call) {
        return switch (call.getModel()) {
            case "qwen-max" -> call.getTokens() * 0.000002;  // ¥0.002/千tokens
            case "gemini-2.0-flash" -> call.getTokens() * 0.00000125;
            default -> 0.0;
        };
    }
}
```

### 6.2 成本优化策略

| 策略 | 预期节省 | 实施难度 | 优先级 |
|-----|---------|---------|--------|
| **请求缓存** | 30-40% | 低 | P0 |
| **用量配额** | 20-30% | 中 | P0 |
| **批量处理** | 15-25% | 高 | P1 |
| **降级策略** | 10-20% | 中 | P1 |
| **本地模型** | 50-70% | 极高 | P2 |

---

## 7. 如何保证生成代码质量

### 7.1 代码质量检查清单

```java
@Service
public class CodeQualityValidator {
    public ValidationResult validate(Map<String, String> generatedFiles) {
        ValidationResult result = new ValidationResult();

        for (Map.Entry<String, String> entry : generatedFiles.entrySet()) {
            String fileName = entry.getKey();
            String code = entry.getValue();

            // 1. 语法检查
            if (!isValidKotlinSyntax(code)) {
                result.addError(fileName, "语法错误");
            }

            // 2. 代码规范检查
            if (!followsCodeStyle(code)) {
                result.addWarning(fileName, "不符合代码规范");
            }

            // 3. 安全检查
            if (containsSensitiveInfo(code)) {
                result.addError(fileName, "包含敏感信息");
            }

            // 4. 性能检查
            if (hasPerformanceIssue(code)) {
                result.addWarning(fileName, "可能存在性能问题");
            }

            // 5. 测试覆盖率
            if (!hasTests(code)) {
                result.addWarning(fileName, "缺少测试");
            }
        }

        return result;
    }
}
```

### 7.2 自动化质量门禁

```yaml
# .github/workflows/code-quality.yml
name: Code Quality Check

on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Kotlin Lint
        run: ./gradlew ktlintCheck

      - name: Detekt (静态分析)
        run: ./gradlew detekt

      - name: 单元测试
        run: ./gradlew test

      - name: 代码覆盖率
        run: ./gradlew jacocoTestReport

      - name: 质量门禁
        run: |
          if [ $(grep -oP '(?<=Total coverage: )\d+' coverage.txt) -lt 85 ]; then
            echo "代码覆盖率低于85%"
            exit 1
          fi
```

---

**文档结束**
