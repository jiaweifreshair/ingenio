# AgentScope + Goose 工程化智能体选型与落地方案（Draft）

> 目标：提升“代码生成一次性通过率”，通过工程化手段让智能体具备 **自主修改代码** 的闭环能力（Generate → Build/Test → Fix → Re-test → Deliver），并与 JeecgBoot 的控制面资产治理体系对齐（文档先行）。

---

## 0. 结论先行（你需要的确认点）

1) **AgentScope 是 Python 框架**（主仓库与生态均以 Python 为第一公民；无官方 Java 版本的主流落地形态）。  
2) 你指定的 **Goose**：`https://github.com/block/goose`。从“工程化自修复 + 可插拔工具 + CI 驱动”的目标看，该类“代码修改执行器/CLI”方向是匹配的，但是否“适合我们系统”仍需要用 PoC 以工程指标验证（见第 4 节）。
3) **“内核逻辑能否复用”**：建议优先以“外部执行器”方式复用 Goose（直接复用其任务循环/工具调用/patch 应用/日志结构），先不要把内核深度嵌入到线上服务里；等 PoC 指标稳定后，再决定是否二次封装成 SDK/服务（见第 3.3 节）。

---

## 1. 目标与边界（文档先行）

### 1.1 目标指标（建议量化）

- **一次性通过率**：一次生成后 `mvn test` + `pnpm typecheck` + 关键 E2E（可选）通过的比例。
- **自修复成功率**：在 N 次修复迭代内（建议 N=3）完成通过的比例。
- **平均修复迭代数**：越低越好（目标 ≤2）。
- **回归风险**：修复引入的“非相关改动”数量（目标趋近 0）。

### 1.2 强约束（已确认/建议固化）

- 控制面：**JeecgBoot** 负责资产（模板/能力/Prompt/评测集）的写入、审批、发布；执行面只读消费。
- 模型：前端/交互可用 **Gemini**；服务端代码生成/修复以 **Claude** 为主（可在控制面按策略路由）。
- 交付：所有变更必须“文档/规范 → 生成 → 验证 → 审计”闭环可追溯。

---

## 2. AgentScope：语言与适配方式

### 2.1 AgentScope 是 Java 还是 Python？

- **结论：Python。**  
  常见用法是作为“多智能体编排框架”，在 Python 运行时内组织角色（Planner/Implementer/Reviewer/Tester）、工具（shell、文件编辑、检索）和对话/记忆。

### 2.2 与你当前技术栈的融合方式（推荐）

> 你已明确“Python Agent 旧实现不保留”，但这不妨碍把 AgentScope 作为 **独立的工程化执行器**（Builder/CI 工具），不作为线上业务服务的一部分。

- **形态 A（推荐）**：独立 `agent-runner`（Python）  
  - 触发方式：Jeecg 控制面发布/或 CI 触发。
  - 输入：需求文档/资产 ID/代码仓库快照（git ref）/验收脚本集合。
  - 输出：PR/patch + 报告（一次通过/迭代次数/失败原因/日志）。
- **形态 B**：不引入 Python 运行时，改用 Java 侧框架（LangChain4j / Spring AI）  
  - 优点：语言栈统一。
  - 缺点：你提出的“AgentScope + Goose”为主不满足；且工程生态/工具成熟度需要重新评估。

---

## 3. Goose：适配性判断框架（你关心的是“能不能把工程闭环跑起来”）

### 3.1 Goose 需要满足的能力清单（用于选型验收）

1) **可控的代码修改能力**：基于 diff/patch 提交变更（避免“整文件重写”）。
2) **工具链集成**：能调用 `mvn test`、`pnpm typecheck`、`pnpm e2e:chromium`、自定义脚本（如 `scripts/v2-validation.ts`）。
3) **迭代策略**：支持“失败 → 解析日志 → 最小修复 → 重试”，并限制最大迭代次数。
4) **安全与隔离**：沙箱/权限控制、敏感信息不出日志、可审计（traceId/actor）。
5) **可观测性**：每次迭代记录（输入、diff、命令、失败栈、结论）。

### 3.2 Goose 在你系统中的推荐定位

- 不把 Goose 当“线上服务”，而是当 **工程执行器**：
  - 运行在 CI/构建机/受控容器；
  - 只对仓库工作区有权限；
  - 产出 patch/PR 与报告；
  - 由 Jeecg 控制面管理策略与资产（Prompt/评测集/模板）。

### 3.3 Goose “内核逻辑”的复用方式（推荐从轻到重）

> 你关心的“内核逻辑”本质是：**任务循环（Plan→Edit→Run→Fix）+ 工具抽象 + patch 应用 + 结构化日志/审计**。

1) **直接复用（推荐 Phase 0/1）**：把 Goose 当 CLI/容器执行器  
   - 优点：最少侵入、最接近上游能力、升级成本低；也更符合“执行面只读消费、控制面治理资产”的分层。  
   - 落地：AgentScope（或 Jeecg 任务调度器）把“文档 + 资产快照 + 验收脚本集合”组装为输入，调用 Goose 运行，收集 diff/日志/指标回写控制面。
2) **二次封装（PoC 稳定后）**：为 Goose 套一层“受控 Runner”  
   - 目的：固化安全边界（只读资产、只允许白名单命令、统一 traceId/审计），并统一输出格式（diff + 测试报告 + 指标）。  
3) **深度复用（最后才考虑）**：Fork 或以库形态嵌入（若 Goose 上游支持）  
   - 风险：需要绑定 Goose 的实现语言/运行时与升级节奏；对你当前“AgentScope（Python）”主编排并不经济，除非你明确要把 Goose 作为长期核心内核。

---

## 4. 建议 PoC（两周内能验证的最小闭环）

### 4.1 PoC 场景选择（尽量贴近你现在的真实痛点）

- 目标：让智能体能在本仓库内把一次生成后的失败修到通过。
- 建议场景（示例）：
  - TS 类型错误修复（`pnpm typecheck`）
  - 后端编译/单测修复（`mvn test`）
  - 关键 API 契约不一致修复（如 templates 列表分页/分类）

### 4.2 PoC 交付物（文档先行）

- `SPEC`：输入/输出契约、验收标准、禁止行为（例如禁止引入 Mock）。
- `RUNBOOK`：如何本地/CI 运行，失败如何定位。
- `EVAL`：评测集（固定用例 + 回归用例），记录一次通过率与修复迭代数。
- `AUDIT`：每次运行的审计字段（requestId、actor、diff 摘要、命令摘要、结论）。

---

## 5. “Gemini 前端 + Claude 服务端”推荐协作分工（落到工程上）

- **Gemini（前端侧）**
  - 产出：页面结构、交互文档、组件拆分方案、类型定义（TS）、可访问性检查清单。
  - 约束：不直接改后端核心链路；优先改 UI/类型/接口调用与文档。
- **Claude（服务端/工程闭环）**
  - 产出：后端实现/修复、测试修复、迁移脚本、审计与安全基线。
  - 约束：每次改动必须能用脚本验证；禁止大范围无关重构。

---

## 6. 下一步需要你确认的 2 个信息

1) Goose 的接入形态：先按 **CLI/容器执行器**（推荐）还是直接做成 **常驻服务**？
2) PoC 的首要目标选哪类失败：`TS 类型` / `Java 单测` / `E2E` / `契约不一致`？
