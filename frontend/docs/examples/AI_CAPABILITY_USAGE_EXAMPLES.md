# AIèƒ½åŠ›ä½¿ç”¨ç¤ºä¾‹å¤§å…¨

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
> **åˆ›å»ºæ—¥æœŸ**: 2025-11-11
> **é€‚ç”¨èŒƒå›´**: Ingenioå¹³å°19ç§AIèƒ½åŠ›
> **æ–‡æ¡£ç”¨é€”**: å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œé›†æˆæŒ‡å—

---

## ç›®å½•

- [å¦‚ä½•ä½¿ç”¨æœ¬æ–‡æ¡£](#å¦‚ä½•ä½¿ç”¨æœ¬æ–‡æ¡£)
- [åŸºç¡€11ç§AIèƒ½åŠ›](#åŸºç¡€11ç§aièƒ½åŠ›)
  - [CHATBOT - æ™ºèƒ½å¯¹è¯æœºå™¨äºº](#chatbot---æ™ºèƒ½å¯¹è¯æœºå™¨äºº)
  - [QA_SYSTEM - é—®ç­”ç³»ç»Ÿ](#qa_system---é—®ç­”ç³»ç»Ÿ)
  - [RAG - æ£€ç´¢å¢å¼ºç”Ÿæˆ](#rag---æ£€ç´¢å¢å¼ºç”Ÿæˆ)
  - [IMAGE_RECOGNITION - å›¾åƒè¯†åˆ«](#image_recognition---å›¾åƒè¯†åˆ«)
  - [OCR_DOCUMENT - OCRæ–‡æ¡£è¯†åˆ«](#ocr_document---ocræ–‡æ¡£è¯†åˆ«)
  - [TRANSLATION - æ™ºèƒ½ç¿»è¯‘](#translation---æ™ºèƒ½ç¿»è¯‘)
  - [SENTIMENT_ANALYSIS - æƒ…æ„Ÿåˆ†æ](#sentiment_analysis---æƒ…æ„Ÿåˆ†æ)
  - [TEXT_GENERATION - æ–‡æœ¬ç”Ÿæˆ](#text_generation---æ–‡æœ¬ç”Ÿæˆ)
  - [CODE_GENERATION - ä»£ç ç”Ÿæˆ](#code_generation---ä»£ç ç”Ÿæˆ)
  - [RECOMMENDATION - æ¨èç³»ç»Ÿ](#recommendation---æ¨èç³»ç»Ÿ)
  - [SPEECH_RECOGNITION - è¯­éŸ³è¯†åˆ«](#speech_recognition---è¯­éŸ³è¯†åˆ«)
  - [CONTENT_MODERATION - å†…å®¹å®¡æ ¸](#content_moderation---å†…å®¹å®¡æ ¸)
  - [SMART_SEARCH - æ™ºèƒ½æœç´¢](#smart_search---æ™ºèƒ½æœç´¢)
- [æ–°å¢8ç§AIèƒ½åŠ›](#æ–°å¢8ç§aièƒ½åŠ›)
  - [VIDEO_ANALYSIS - è§†é¢‘åˆ†æ](#video_analysis---è§†é¢‘åˆ†æ)
  - [KNOWLEDGE_GRAPH - çŸ¥è¯†å›¾è°±](#knowledge_graph---çŸ¥è¯†å›¾è°±)
  - [REALTIME_STREAM - å®æ—¶æµå¤„ç†](#realtime_stream---å®æ—¶æµå¤„ç†)
  - [HYPER_PERSONALIZATION - è¶…ä¸ªæ€§åŒ–æ¨è](#hyper_personalization---è¶…ä¸ªæ€§åŒ–æ¨è)
  - [PREDICTIVE_ANALYTICS - é¢„æµ‹åˆ†æ](#predictive_analytics---é¢„æµ‹åˆ†æ)
  - [MULTIMODAL_GENERATION - å¤šæ¨¡æ€ç”Ÿæˆ](#multimodal_generation---å¤šæ¨¡æ€ç”Ÿæˆ)
  - [ANOMALY_DETECTION - å¼‚å¸¸æ£€æµ‹](#anomaly_detection---å¼‚å¸¸æ£€æµ‹)
- [é™„å½•](#é™„å½•)
  - [APIå¯†é’¥é…ç½®](#apiå¯†é’¥é…ç½®)
  - [æˆæœ¬ä¼˜åŒ–å»ºè®®](#æˆæœ¬ä¼˜åŒ–å»ºè®®)
  - [å¸¸è§é—®é¢˜FAQ](#å¸¸è§é—®é¢˜faq)

---

## å¦‚ä½•ä½¿ç”¨æœ¬æ–‡æ¡£

### å¿«é€Ÿå¯¼èˆª

1. **æ‰¾åˆ°ä½ éœ€è¦çš„AIèƒ½åŠ›ç±»å‹**
   - æŒ‰ç›®å½•æµè§ˆ19ç§AIèƒ½åŠ›
   - æŸ¥çœ‹æ¯ç§èƒ½åŠ›çš„é€‚ç”¨åœºæ™¯

2. **å¤åˆ¶ç¤ºä¾‹ä»£ç åˆ°ä½ çš„é¡¹ç›®**
   - å‰ç«¯ä½¿ç”¨ç¤ºä¾‹ï¼ˆTypeScriptï¼‰
   - åç«¯ç”Ÿæˆçš„ä»£ç ç»“æ„
   - ç”Ÿæˆçš„Kotlinä»£ç ç¤ºä¾‹

3. **æ ¹æ®æ³¨é‡Šä¿®æ”¹é…ç½®å‚æ•°**
   - APIå¯†é’¥é…ç½®
   - æ¨¡å‹å‚æ•°è°ƒæ•´
   - æˆæœ¬æ§åˆ¶ç­–ç•¥

4. **è¿è¡Œæµ‹è¯•éªŒè¯åŠŸèƒ½**
   - æœ¬åœ°æµ‹è¯•å‘½ä»¤
   - E2Eæµ‹è¯•ç”¨ä¾‹
   - æ€§èƒ½ç›‘æ§æŒ‡æ ‡

### æ–‡æ¡£çº¦å®š

- **ä»£ç å—**: å¯ç›´æ¥å¤åˆ¶ä½¿ç”¨çš„ä»£ç ç‰‡æ®µ
- **âš ï¸ æ³¨æ„**: éœ€è¦ç‰¹åˆ«å…³æ³¨çš„é‡è¦ä¿¡æ¯
- **ğŸ’¡ æç¤º**: ä¼˜åŒ–å»ºè®®å’Œæœ€ä½³å®è·µ
- **ğŸ”§ é…ç½®**: å¿…éœ€çš„é…ç½®é¡¹

---

## åŸºç¡€11ç§AIèƒ½åŠ›

### CHATBOT - æ™ºèƒ½å¯¹è¯æœºå™¨äºº

#### é€‚ç”¨åœºæ™¯

1. **å®¢æœæœºå™¨äºº** - 24/7è‡ªåŠ¨å›ç­”å®¢æˆ·é—®é¢˜ï¼Œå‡å°‘äººå·¥æˆæœ¬
2. **è™šæ‹ŸåŠ©æ‰‹** - å¸®åŠ©ç”¨æˆ·å®Œæˆä»»åŠ¡ï¼Œå¦‚æ—¥ç¨‹ç®¡ç†ã€ä¿¡æ¯æŸ¥è¯¢
3. **èŠå¤©åº”ç”¨** - ä¸ºç¤¾äº¤åº”ç”¨æä¾›AIèŠå¤©åŠŸèƒ½
4. **æ™ºèƒ½é—®ç­”** - ä¼ä¸šå†…éƒ¨çŸ¥è¯†åº“é—®ç­”
5. **æ•™è‚²è¾…å¯¼** - AIè€å¸ˆï¼Œè§£ç­”å­¦ç”Ÿé—®é¢˜

#### æŠ€æœ¯å®ç°

- **AIæ¨¡å‹**: é˜¿é‡Œäº‘é€šä¹‰åƒé—® Qwen-Max
- **æˆæœ¬ä¼°ç®—**: $1.7/æœˆï¼ˆ1ä¸‡æ´»è·ƒç”¨æˆ·ï¼‰
- **é¢„ä¼°å·¥æœŸ**: 2å¤©
- **å¤æ‚åº¦**: SIMPLE

#### å‰ç«¯ä½¿ç”¨ç¤ºä¾‹

```typescript
// frontend/src/pages/ChatbotDemo.tsx
import { AICapabilityPicker } from '@/components/ai/ai-capability-picker';
import { AICapabilityType } from '@/types/ai-capability';
import { useState } from 'react';

function ChatbotDemo() {
  const [selectedCapabilities, setSelectedCapabilities] = useState<AICapabilityType[]>([
    AICapabilityType.CHATBOT
  ]);

  const handleSelect = (capabilities: AICapabilityType[]) => {
    setSelectedCapabilities(capabilities);
    // è°ƒç”¨åç«¯ç”Ÿæˆä»£ç API
    generateCode(capabilities);
  };

  const generateCode = async (capabilities: AICapabilityType[]) => {
    const response = await fetch('/api/v1/wizard/generate-code', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        aiCapabilities: capabilities,
        packageName: 'com.example.chatapp',
        appName: 'My Chat App'
      })
    });

    const { zipUrl } = await response.json();
    // ä¸‹è½½ç”Ÿæˆçš„ä»£ç ZIP
    window.location.href = zipUrl;
  };

  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">æ™ºèƒ½å¯¹è¯æœºå™¨äººç¤ºä¾‹</h1>
      <AICapabilityPicker
        selectedCapabilities={selectedCapabilities}
        onSelectionChange={handleSelect}
        userRequirement="æˆ‘éœ€è¦æ„å»ºä¸€ä¸ªæ™ºèƒ½å®¢æœç³»ç»Ÿ"
      />
    </div>
  );
}

export default ChatbotDemo;
```

#### åç«¯ç”Ÿæˆçš„ä»£ç ç»“æ„

```
com.example.chatapp/
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ ChatbotService.kt          # AIæœåŠ¡ä¸»ç±»
â”‚   â”œâ”€â”€ ConversationManager.kt     # å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†
â”‚   â””â”€â”€ MessageHistory.kt          # æ¶ˆæ¯å†å²è®°å½•
â”œâ”€â”€ presentation/
â”‚   â”œâ”€â”€ viewmodel/
â”‚   â”‚   â””â”€â”€ ChatViewModel.kt       # ViewModel
â”‚   â””â”€â”€ ui/
â”‚       â””â”€â”€ ChatScreen.kt          # Compose UI
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ ChatMessage.kt         # æ¶ˆæ¯æ•°æ®æ¨¡å‹
â”‚   â”‚   â””â”€â”€ ChatSession.kt         # ä¼šè¯æ•°æ®æ¨¡å‹
â”‚   â””â”€â”€ repository/
â”‚       â””â”€â”€ ChatRepository.kt      # æ•°æ®ä»“åº“
â””â”€â”€ config/
    â””â”€â”€ AIConfig.kt                # AIé…ç½®ï¼ˆAPI Keyç­‰ï¼‰
```

#### ç”Ÿæˆçš„Kotlinä»£ç ç¤ºä¾‹

```kotlin
// core/src/commonMain/kotlin/com/example/chatapp/ai/ChatbotService.kt
package com.example.chatapp.ai

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * æ™ºèƒ½å¯¹è¯æœºå™¨äººæœåŠ¡
 * åŸºäºé˜¿é‡Œäº‘é€šä¹‰åƒé—®Qwen-Maxå®ç°
 *
 * åŠŸèƒ½ï¼š
 * - sendMessage(): å‘é€æ¶ˆæ¯å¹¶è·å–AIå›å¤
 * - streamMessage(): æµå¼å“åº”ï¼ˆSSEï¼‰
 * - clearHistory(): æ¸…ç©ºå¯¹è¯å†å²
 *
 * Generated by Ingenio Platform
 * Date: 2025-11-11
 */
class ChatbotService(
    private val apiKey: String,
    private val baseUrl: String = "https://dashscope.aliyuncs.com/api/v1",
    private val model: String = "qwen-max"
) {
    private val httpClient = HttpClient(CIO) {
        install(ContentNegotiation) {
            json(Json {
                prettyPrint = true
                isLenient = true
                ignoreUnknownKeys = true
            })
        }
        engine {
            requestTimeout = 60_000 // 60ç§’è¶…æ—¶
        }
    }

    private val conversationHistory = mutableListOf<ChatMessage>()

    /**
     * å‘é€æ¶ˆæ¯å¹¶è·å–AIå›å¤
     *
     * @param userMessage ç”¨æˆ·æ¶ˆæ¯
     * @param systemPrompt ç³»ç»Ÿæç¤ºè¯ï¼ˆå¯é€‰ï¼‰
     * @return AIå›å¤å†…å®¹
     */
    suspend fun sendMessage(
        userMessage: String,
        systemPrompt: String = "ä½ æ˜¯ä¸€ä¸ªå‹å¥½çš„AIåŠ©æ‰‹ï¼Œæ“…é•¿å›ç­”å„ç§é—®é¢˜ã€‚"
    ): ChatResponse {
        // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°å†å²
        conversationHistory.add(ChatMessage("user", userMessage))

        // æ„å»ºè¯·æ±‚
        val request = ChatRequest(
            model = model,
            input = ChatInput(
                messages = buildMessages(systemPrompt)
            ),
            parameters = ChatParameters(
                temperature = 0.7,
                maxTokens = 1500,
                topP = 0.9
            )
        )

        // å‘é€è¯·æ±‚
        val response = httpClient.post("$baseUrl/services/aigc/text-generation/generation") {
            header("Authorization", "Bearer $apiKey")
            header("Content-Type", "application/json")
            setBody(request)
        }

        if (response.status != HttpStatusCode.OK) {
            throw ChatbotException("è¯·æ±‚å¤±è´¥: ${response.status}")
        }

        val chatResponse: ChatResponse = response.body()

        // æ·»åŠ AIå›å¤åˆ°å†å²
        conversationHistory.add(ChatMessage("assistant", chatResponse.output.text))

        return chatResponse
    }

    /**
     * æ¸…ç©ºå¯¹è¯å†å²
     */
    fun clearHistory() {
        conversationHistory.clear()
    }

    /**
     * è·å–å¯¹è¯å†å²
     */
    fun getHistory(): List<ChatMessage> {
        return conversationHistory.toList()
    }

    /**
     * æ„å»ºæ¶ˆæ¯åˆ—è¡¨ï¼ˆåŒ…å«ç³»ç»Ÿæç¤ºå’Œå†å²ï¼‰
     */
    private fun buildMessages(systemPrompt: String): List<Message> {
        val messages = mutableListOf<Message>()

        // ç³»ç»Ÿæç¤º
        messages.add(Message("system", systemPrompt))

        // å¯¹è¯å†å²
        conversationHistory.forEach { msg ->
            messages.add(Message(msg.role, msg.content))
        }

        return messages
    }

    /**
     * å…³é—­HTTPå®¢æˆ·ç«¯
     */
    fun close() {
        httpClient.close()
    }
}

// ==================== æ•°æ®æ¨¡å‹ ====================

/**
 * èŠå¤©æ¶ˆæ¯
 */
@Serializable
data class ChatMessage(
    val role: String,      // "user" | "assistant" | "system"
    val content: String,
    val timestamp: Long = System.currentTimeMillis()
)

/**
 * èŠå¤©è¯·æ±‚
 */
@Serializable
data class ChatRequest(
    val model: String,
    val input: ChatInput,
    val parameters: ChatParameters
)

@Serializable
data class ChatInput(
    val messages: List<Message>
)

@Serializable
data class Message(
    val role: String,
    val content: String
)

@Serializable
data class ChatParameters(
    val temperature: Double,
    val maxTokens: Int,
    val topP: Double
)

/**
 * èŠå¤©å“åº”
 */
@Serializable
data class ChatResponse(
    val output: ChatOutput,
    val usage: Usage,
    val requestId: String
)

@Serializable
data class ChatOutput(
    val text: String,
    val finishReason: String
)

@Serializable
data class Usage(
    val inputTokens: Int,
    val outputTokens: Int,
    val totalTokens: Int
)

/**
 * èŠå¤©æœºå™¨äººå¼‚å¸¸
 */
class ChatbotException(message: String) : Exception(message)
```

#### é›†æˆæ­¥éª¤

**æ­¥éª¤1**: åœ¨Supabaseä¸­é…ç½®AI APIå¯†é’¥

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º local.properties
echo "QWEN_API_KEY=your_api_key_here" > local.properties
```

**æ­¥éª¤2**: åœ¨é¡¹ç›®ä¸­æ·»åŠ ä¾èµ–

```kotlin
// build.gradle.kts
dependencies {
    implementation("io.ktor:ktor-client-core:2.3.5")
    implementation("io.ktor:ktor-client-cio:2.3.5")
    implementation("io.ktor:ktor-client-content-negotiation:2.3.5")
    implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.5")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.0")
}
```

**æ­¥éª¤3**: åˆå§‹åŒ–ChatbotService

```kotlin
// Applicationåˆå§‹åŒ–
val apiKey = AIConfig.qwenApiKey
val chatbotService = ChatbotService(apiKey)

// ä½¿ç”¨ç¤ºä¾‹
suspend fun chatExample() {
    val response = chatbotService.sendMessage("ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹è‡ªå·±")
    println("AIå›å¤: ${response.output.text}")
}
```

#### å¸¸è§é—®é¢˜

**Q1: å¦‚ä½•å¤„ç†æµå¼å“åº”ï¼Ÿ**

A: ä½¿ç”¨SSEï¼ˆServer-Sent Eventsï¼‰æ”¯æŒæµå¼å“åº”ï¼š

```kotlin
suspend fun streamMessage(userMessage: String): Flow<String> = flow {
    val request = ChatRequest(
        model = model,
        input = ChatInput(messages = buildMessages()),
        parameters = ChatParameters(
            temperature = 0.7,
            maxTokens = 1500,
            topP = 0.9,
            enableStream = true  // å¯ç”¨æµå¼å“åº”
        )
    )

    httpClient.preparePost("$baseUrl/services/aigc/text-generation/generation") {
        header("Authorization", "Bearer $apiKey")
        header("Content-Type", "application/json")
        setBody(request)
    }.execute { response ->
        val channel = response.body<ByteReadChannel>()
        while (!channel.isClosedForRead) {
            val line = channel.readUTF8Line() ?: break
            if (line.startsWith("data:")) {
                val data = line.substring(5).trim()
                emit(data)
            }
        }
    }
}
```

**Q2: å¦‚ä½•æ§åˆ¶å›å¤é•¿åº¦ï¼Ÿ**

A: åœ¨ChatParametersä¸­è®¾ç½®max_tokenså‚æ•°ï¼š

```kotlin
ChatParameters(
    maxTokens = 500,  // é™åˆ¶æœ€å¤š500ä¸ªtoken
    temperature = 0.7,
    topP = 0.9
)
```

**Q3: å¦‚ä½•å¤„ç†å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡ï¼Ÿ**

A: ä½¿ç”¨ConversationHistoryä¿å­˜å¯¹è¯å†å²ï¼š

```kotlin
class ConversationManager {
    private val history = mutableListOf<ChatMessage>()
    private val maxHistorySize = 10  // æœ€å¤šä¿ç•™10è½®å¯¹è¯

    fun addMessage(message: ChatMessage) {
        history.add(message)
        if (history.size > maxHistorySize * 2) {  // æ¯è½®2æ¡æ¶ˆæ¯
            history.removeAt(0)
            history.removeAt(0)
        }
    }

    fun getHistory(): List<ChatMessage> = history.toList()
}
```

**Q4: å¦‚ä½•ä¼°ç®—æˆæœ¬ï¼Ÿ**

A: Tokenæ¶ˆè€—ä¼°ç®—å…¬å¼ï¼š

```
æˆæœ¬ = (è¾“å…¥Tokenæ•° + è¾“å‡ºTokenæ•°) Ã— å•ä»·
å•ä»·ï¼ˆQwen-Maxï¼‰= Â¥0.002/åƒtokens â‰ˆ $0.00028/åƒtokens

ç¤ºä¾‹ï¼š
- å¹³å‡æ¯æ¬¡å¯¹è¯ï¼š500 tokens
- æ¯æ—¥æ´»è·ƒç”¨æˆ·ï¼š1000äºº
- æ¯äººæ¯å¤©å¯¹è¯ï¼š5æ¬¡
æˆæœ¬ = 1000 Ã— 5 Ã— 500 / 1000 Ã— 0.002 = Â¥5/å¤© â‰ˆ $150/æœˆ
```

**Q5: å¦‚ä½•ä¼˜åŒ–å“åº”é€Ÿåº¦ï¼Ÿ**

A: ä¸‰ç§ä¼˜åŒ–ç­–ç•¥ï¼š

```kotlin
// ç­–ç•¥1: é™ä½max_tokens
ChatParameters(maxTokens = 300)  // ä»1500é™åˆ°300

// ç­–ç•¥2: ä½¿ç”¨æ›´å¿«çš„æ¨¡å‹
ChatbotService(model = "qwen-turbo")  // ä»qwen-maxåˆ‡æ¢åˆ°qwen-turbo

// ç­–ç•¥3: å¯ç”¨ç¼“å­˜
@Cacheable(value = "chat-responses", key = "#userMessage")
suspend fun sendMessage(userMessage: String): ChatResponse
```

---

### VIDEO_ANALYSIS - è§†é¢‘åˆ†æ

#### é€‚ç”¨åœºæ™¯

1. **çŸ­è§†é¢‘åº”ç”¨** - è‡ªåŠ¨ç”Ÿæˆè§†é¢‘æ ‡ç­¾ã€æ¨èç›¸å…³å†…å®¹
2. **å†…å®¹å®¡æ ¸** - æ£€æµ‹è¿è§„å†…å®¹ï¼ˆæš´åŠ›ã€è‰²æƒ…ã€æ”¿æ²»æ•æ„Ÿï¼‰
3. **æ™ºèƒ½ç›‘æ§** - å¼‚å¸¸è¡Œä¸ºæ£€æµ‹ã€äººæµç»Ÿè®¡
4. **è§†é¢‘ç¼–è¾‘** - æ™ºèƒ½è¯†åˆ«ç²¾å½©ç‰‡æ®µã€è‡ªåŠ¨å‰ªè¾‘
5. **ç”µå•†åº”ç”¨** - è§†é¢‘å•†å“è¯†åˆ«ã€ç©¿æ­åˆ†æ

#### æŠ€æœ¯å®ç°

- **AIæ¨¡å‹**: é˜¿é‡Œäº‘é€šä¹‰åƒé—® Qwen-VL-Maxï¼ˆè§†è§‰è¯­è¨€æ¨¡å‹ï¼‰
- **æˆæœ¬ä¼°ç®—**: $50/æœˆï¼ˆ5ä¸‡æ¬¡è°ƒç”¨ï¼‰
- **é¢„ä¼°å·¥æœŸ**: 5å¤©
- **å¤æ‚åº¦**: MEDIUM

#### å‰ç«¯ä½¿ç”¨ç¤ºä¾‹

```typescript
// frontend/src/pages/VideoAnalysisDemo.tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

interface VideoAnalysisResult {
  objects: Array<{ name: string; confidence: number }>;
  scenes: Array<{ type: string; timestamp: string }>;
  actions: Array<{ action: string; duration: string }>;
  summary: string;
}

function VideoAnalysisDemo() {
  const [videoUrl, setVideoUrl] = useState('');
  const [analyzing, setAnalyzing] = useState(false);
  const [result, setResult] = useState<VideoAnalysisResult | null>(null);

  const analyzeVideo = async () => {
    setAnalyzing(true);
    try {
      const response = await fetch('/api/v1/ai/video-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoUrl })
      });

      const data = await response.json();
      setResult(data);
    } catch (error) {
      console.error('è§†é¢‘åˆ†æå¤±è´¥:', error);
    } finally {
      setAnalyzing(false);
    }
  };

  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">è§†é¢‘åˆ†æç¤ºä¾‹</h1>

      <div className="space-y-4">
        <Input
          type="text"
          placeholder="è¾“å…¥è§†é¢‘URL"
          value={videoUrl}
          onChange={(e) => setVideoUrl(e.target.value)}
        />

        <Button onClick={analyzeVideo} disabled={analyzing}>
          {analyzing ? 'åˆ†æä¸­...' : 'å¼€å§‹åˆ†æ'}
        </Button>

        {result && (
          <div className="mt-6 space-y-4">
            <div>
              <h3 className="font-semibold">æ£€æµ‹åˆ°çš„ç‰©ä½“</h3>
              <ul className="list-disc list-inside">
                {result.objects.map((obj, i) => (
                  <li key={i}>
                    {obj.name} (ç½®ä¿¡åº¦: {(obj.confidence * 100).toFixed(1)}%)
                  </li>
                ))}
              </ul>
            </div>

            <div>
              <h3 className="font-semibold">åœºæ™¯è¯†åˆ«</h3>
              <ul className="list-disc list-inside">
                {result.scenes.map((scene, i) => (
                  <li key={i}>
                    {scene.type} - {scene.timestamp}
                  </li>
                ))}
              </ul>
            </div>

            <div>
              <h3 className="font-semibold">è§†é¢‘æ‘˜è¦</h3>
              <p>{result.summary}</p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default VideoAnalysisDemo;
```

#### åç«¯ç”Ÿæˆçš„ä»£ç ç»“æ„

```
com.example.videoapp/
â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ VideoAnalysisService.kt    # è§†é¢‘åˆ†ææœåŠ¡
â”‚   â”œâ”€â”€ VideoFrameExtractor.kt     # è§†é¢‘å¸§æå–å™¨
â”‚   â””â”€â”€ VideoAnalysisResult.kt     # åˆ†æç»“æœæ•°æ®æ¨¡å‹
â”œâ”€â”€ presentation/
â”‚   â”œâ”€â”€ viewmodel/
â”‚   â”‚   â””â”€â”€ VideoAnalysisViewModel.kt  # ViewModel
â”‚   â””â”€â”€ ui/
â”‚       â””â”€â”€ VideoAnalysisScreen.kt     # Compose UI
â””â”€â”€ config/
    â””â”€â”€ VideoAnalysisConfig.kt     # é…ç½®æ–‡ä»¶
```

#### ç”Ÿæˆçš„Kotlinä»£ç ç¤ºä¾‹

ï¼ˆä»£ç ç¤ºä¾‹å·²åœ¨AICodeGenerator.javaä¸­å®Œæ•´æä¾›ï¼Œè¿™é‡Œå¼•ç”¨ï¼‰

```kotlin
// å‚è§ AICodeGenerator.java ç¬¬193-477è¡Œ
// å®Œæ•´çš„VideoAnalysisService.ktå®ç°
```

#### é›†æˆæ­¥éª¤

**æ­¥éª¤1**: é…ç½®APIå¯†é’¥

```properties
# local.properties
QWEN_API_KEY=sk-your-api-key-here
```

**æ­¥éª¤2**: æ·»åŠ ä¾èµ–

```kotlin
dependencies {
    implementation("io.ktor:ktor-client-core:2.3.5")
    implementation("io.ktor:ktor-client-cio:2.3.5")
    implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.5")
}
```

**æ­¥éª¤3**: ä½¿ç”¨ç¤ºä¾‹

```kotlin
val service = VideoAnalysisService(apiKey)
val result = service.analyzeVideo(
    videoUrl = "https://example.com/video.mp4",
    prompt = "åˆ†æè¿™ä¸ªè§†é¢‘ä¸­çš„ä¸»è¦ç‰©ä½“å’Œåœºæ™¯"
)

println("æ£€æµ‹åˆ° ${result.objects.size} ä¸ªç‰©ä½“")
result.objects.forEach { obj ->
    println("  - ${obj.name} (ç½®ä¿¡åº¦: ${obj.confidence})")
}
```

#### å¸¸è§é—®é¢˜

**Q1: å¦‚ä½•å¤„ç†å¤§è§†é¢‘æ–‡ä»¶ï¼Ÿ**

A: ä½¿ç”¨åˆ†ç‰‡ä¸Šä¼ å’Œå¼‚æ­¥å¤„ç†ï¼š

```kotlin
class VideoUploader {
    suspend fun uploadLargeVideo(videoFile: File): String {
        val chunkSize = 5 * 1024 * 1024  // 5MB per chunk
        val chunks = videoFile.readBytes().toList().chunked(chunkSize)

        chunks.forEachIndexed { index, chunk ->
            uploadChunk(chunk.toByteArray(), index)
        }

        return "upload-task-id"
    }
}
```

**Q2: å¦‚ä½•ä¼˜åŒ–è§†é¢‘åˆ†ææˆæœ¬ï¼Ÿ**

A: ä¸‰ç§ç­–ç•¥ï¼š

```kotlin
// ç­–ç•¥1: é™ä½é‡‡æ ·ç‡ï¼ˆæ¯60å¸§åˆ†æä¸€æ¬¡ï¼‰
VideoAnalysisRequest(
    videoUrl = videoUrl,
    frameInterval = 60  // ä»30å¢åŠ åˆ°60
)

// ç­–ç•¥2: é™åˆ¶åˆ†æå¸§æ•°
VideoAnalysisRequest(
    videoUrl = videoUrl,
    maxFrames = 50  // ä»100å‡å°‘åˆ°50
)

// ç­–ç•¥3: ç¼“å­˜åˆ†æç»“æœ
@Cacheable(value = "video-analysis", key = "#videoUrl")
suspend fun analyzeVideo(videoUrl: String): VideoAnalysisResult
```

**Q3: å¦‚ä½•å¤„ç†å®æ—¶è§†é¢‘æµï¼Ÿ**

A: ä½¿ç”¨WebSocketæµå¼å¤„ç†ï¼š

```kotlin
suspend fun analyzeVideoStream(videoStream: Flow<ByteArray>) {
    videoStream.collect { frame ->
        val result = analyzeFrame(frame)
        emit(result)
    }
}
```

**Q4: æ”¯æŒå“ªäº›è§†é¢‘æ ¼å¼ï¼Ÿ**

A: æ”¯æŒå¸¸è§è§†é¢‘æ ¼å¼ï¼š

- MP4
- AVI
- MOV
- FLV
- WebM

**Q5: å¦‚ä½•æé«˜è¯†åˆ«å‡†ç¡®ç‡ï¼Ÿ**

A: ä¼˜åŒ–æç¤ºè¯ï¼ˆPromptï¼‰ï¼š

```kotlin
// é€šç”¨æç¤ºè¯
"åˆ†æè¿™ä¸ªè§†é¢‘"

// ä¼˜åŒ–åçš„æç¤ºè¯
"""
è¯·è¯¦ç»†åˆ†æè¿™ä¸ªè§†é¢‘ï¼š
1. è¯†åˆ«æ‰€æœ‰å‡ºç°çš„ç‰©ä½“ï¼ˆäººç‰©ã€è½¦è¾†ã€å»ºç­‘ç­‰ï¼‰
2. è¯†åˆ«åœºæ™¯ç±»å‹ï¼ˆå®¤å†…/å®¤å¤–ã€åŸå¸‚/è‡ªç„¶ç­‰ï¼‰
3. è¯†åˆ«ä¸»è¦åŠ¨ä½œï¼ˆè·‘æ­¥ã€è·³èˆã€é©¾é©¶ç­‰ï¼‰
4. ç”Ÿæˆ100å­—ä»¥å†…çš„è§†é¢‘æ‘˜è¦
è¿”å›JSONæ ¼å¼çš„åˆ†ææŠ¥å‘Šã€‚
"""
```

---

### KNOWLEDGE_GRAPH - çŸ¥è¯†å›¾è°±

#### é€‚ç”¨åœºæ™¯

1. **ä¼ä¸šçŸ¥è¯†åº“** - è‡ªåŠ¨æ„å»ºå‘˜å·¥ã€é¡¹ç›®ã€æ–‡æ¡£çš„å…³ç³»ç½‘ç»œ
2. **å­¦ä¹ åº”ç”¨** - çŸ¥è¯†ç‚¹å…³è”ã€å­¦ä¹ è·¯å¾„æ¨è
3. **å†…å®¹å¹³å°** - æ–‡ç« ã€ä½œè€…ã€è¯é¢˜çš„è¯­ä¹‰è¿æ¥
4. **ç”µå•†åº”ç”¨** - å•†å“å±æ€§æå–ã€ç›¸ä¼¼å•†å“æ¨è
5. **æ³•å¾‹ç§‘æŠ€** - æ¡ˆä¾‹å…³è”ã€æ³•æ¡å¼•ç”¨åˆ†æ

#### æŠ€æœ¯å®ç°

- **AIæ¨¡å‹**: é˜¿é‡Œäº‘é€šä¹‰åƒé—® Qwen-Maxï¼ˆå®ä½“å…³ç³»æå–ï¼‰
- **æˆæœ¬ä¼°ç®—**: $28/æœˆï¼ˆ10ä¸‡æ¬¡è°ƒç”¨ï¼‰
- **é¢„ä¼°å·¥æœŸ**: 8å¤©
- **å¤æ‚åº¦**: COMPLEX

#### å‰ç«¯ä½¿ç”¨ç¤ºä¾‹

```typescript
// frontend/src/pages/KnowledgeGraphDemo.tsx
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import ReactFlow, { Node, Edge } from 'reactflow';
import 'reactflow/dist/style.css';

interface Entity {
  id: string;
  name: string;
  type: string;
}

interface Relation {
  subject: string;
  predicate: string;
  object: string;
  confidence: number;
}

function KnowledgeGraphDemo() {
  const [text, setText] = useState('');
  const [extracting, setExtracting] = useState(false);
  const [nodes, setNodes] = useState<Node[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);

  const extractGraph = async () => {
    setExtracting(true);
    try {
      const response = await fetch('/api/v1/ai/knowledge-graph', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });

      const { entities, relations } = await response.json();

      // è½¬æ¢ä¸ºReactFlowèŠ‚ç‚¹å’Œè¾¹
      const flowNodes = entities.map((entity: Entity, index: number) => ({
        id: entity.id,
        data: { label: `${entity.name} (${entity.type})` },
        position: { x: index * 200, y: index * 100 }
      }));

      const flowEdges = relations.map((rel: Relation) => ({
        id: `${rel.subject}-${rel.object}`,
        source: rel.subject,
        target: rel.object,
        label: rel.predicate,
        animated: true
      }));

      setNodes(flowNodes);
      setEdges(flowEdges);
    } catch (error) {
      console.error('çŸ¥è¯†å›¾è°±æå–å¤±è´¥:', error);
    } finally {
      setExtracting(false);
    }
  };

  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">çŸ¥è¯†å›¾è°±ç¤ºä¾‹</h1>

      <div className="space-y-4">
        <Textarea
          placeholder="è¾“å…¥æ–‡æœ¬ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨æå–å®ä½“å’Œå…³ç³»..."
          value={text}
          onChange={(e) => setText(e.target.value)}
          rows={6}
        />

        <Button onClick={extractGraph} disabled={extracting}>
          {extracting ? 'æå–ä¸­...' : 'æå–çŸ¥è¯†å›¾è°±'}
        </Button>

        {nodes.length > 0 && (
          <div style={{ height: 600 }}>
            <ReactFlow nodes={nodes} edges={edges} fitView />
          </div>
        )}
      </div>
    </div>
  );
}

export default KnowledgeGraphDemo;
```

#### åç«¯ç”Ÿæˆçš„ä»£ç ç»“æ„

ï¼ˆå‚è§AICodeGenerator.java ç¬¬486-710è¡Œï¼‰

#### ç”Ÿæˆçš„Kotlinä»£ç ç¤ºä¾‹

ï¼ˆå‚è§AICodeGenerator.java ç¬¬492-591è¡Œï¼‰

#### é›†æˆæ­¥éª¤

**æ­¥éª¤1**: é…ç½®APIå¯†é’¥ï¼ˆåŒä¸Šï¼‰

**æ­¥éª¤2**: æ·»åŠ å›¾æ•°æ®åº“æ”¯æŒï¼ˆå¯é€‰ï¼‰

```kotlin
// ä½¿ç”¨Neo4jå­˜å‚¨çŸ¥è¯†å›¾è°±
dependencies {
    implementation("org.neo4j.driver:neo4j-java-driver:5.14.0")
}

class Neo4jGraphRepository(
    private val uri: String,
    private val username: String,
    private val password: String
) {
    private val driver = GraphDatabase.driver(uri, AuthTokens.basic(username, password))

    fun saveGraph(graph: KnowledgeGraph) {
        driver.session().use { session ->
            graph.entities.forEach { entity ->
                session.writeTransaction { tx ->
                    tx.run(
                        "CREATE (e:Entity {id: \$id, name: \$name, type: \$type})",
                        mapOf("id" to entity.id, "name" to entity.name, "type" to entity.type)
                    )
                }
            }

            graph.relations.forEach { relation ->
                session.writeTransaction { tx ->
                    tx.run(
                        "MATCH (a:Entity {id: \$subject}), (b:Entity {id: \$object}) " +
                        "CREATE (a)-[r:\$predicate]->(b)",
                        mapOf(
                            "subject" to relation.subject,
                            "object" to relation.object,
                            "predicate" to relation.predicate
                        )
                    )
                }
            }
        }
    }
}
```

**æ­¥éª¤3**: ä½¿ç”¨ç¤ºä¾‹

```kotlin
val service = KnowledgeGraphService(apiKey)
val graph = service.extractEntitiesAndRelations(
    "è‹¹æœå…¬å¸ç”±å²è’‚å¤«Â·ä¹”å¸ƒæ–¯åˆ›ç«‹äº1976å¹´ï¼Œæ€»éƒ¨ä½äºåŠ å·åº“æ¯”è’‚è¯ºã€‚"
)

println("æå–åˆ° ${graph.entities.size} ä¸ªå®ä½“")
println("æå–åˆ° ${graph.relations.size} ä¸ªå…³ç³»")

graph.entities.forEach { entity ->
    println("å®ä½“: ${entity.name} (${entity.type})")
}

graph.relations.forEach { relation ->
    println("å…³ç³»: ${relation.subject} ${relation.predicate} ${relation.object}")
}
```

#### å¸¸è§é—®é¢˜

**Q1: å¦‚ä½•æé«˜å®ä½“è¯†åˆ«å‡†ç¡®ç‡ï¼Ÿ**

A: ä½¿ç”¨æ›´è¯¦ç»†çš„å®ä½“ç±»å‹å®šä¹‰ï¼š

```kotlin
data class EntityType(
    val name: String,
    val examples: List<String>,
    val keywords: List<String>
)

val customEntityTypes = listOf(
    EntityType(
        name = "PERSON",
        examples = listOf("å¼ ä¸‰", "æå››", "å²è’‚å¤«Â·ä¹”å¸ƒæ–¯"),
        keywords = listOf("å…ˆç”Ÿ", "å¥³å£«", "æ•™æˆ", "åšå£«")
    ),
    EntityType(
        name = "ORGANIZATION",
        examples = listOf("è‹¹æœå…¬å¸", "æ¸…åå¤§å­¦", "å›½åŠ¡é™¢"),
        keywords = listOf("å…¬å¸", "å¤§å­¦", "æ”¿åºœ", "æœºæ„")
    )
)
```

**Q2: å¦‚ä½•å¤„ç†å…³ç³»å†²çªï¼Ÿ**

A: ä½¿ç”¨ç½®ä¿¡åº¦è¯„åˆ†å’Œå†²çªè§£å†³ç­–ç•¥ï¼š

```kotlin
class ConflictResolver {
    fun resolveRelationConflicts(relations: List<Relation>): List<Relation> {
        // æŒ‰ä¸»è¯­-å®¾è¯­åˆ†ç»„
        val grouped = relations.groupBy { "${it.subject}-${it.object}" }

        return grouped.values.map { group ->
            // é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„å…³ç³»
            group.maxByOrNull { it.confidence } ?: group.first()
        }
    }
}
```

**Q3: å¦‚ä½•å®ç°å…³ç³»æ¨ç†ï¼Ÿ**

A: ä½¿ç”¨è§„åˆ™å¼•æ“è¿›è¡Œæ¨ç†ï¼š

```kotlin
class GraphReasoner {
    fun inferRelations(graph: KnowledgeGraph): List<Relation> {
        val inferred = mutableListOf<Relation>()

        // è§„åˆ™1: ä¼ é€’æ€§ï¼ˆAåˆ›ç«‹Bï¼ŒBä½äºC => Aå…³è”Cï¼‰
        graph.relations.filter { it.predicate == "åˆ›ç«‹" }.forEach { r1 ->
            graph.relations.filter { it.predicate == "ä½äº" && it.subject == r1.object }.forEach { r2 ->
                inferred.add(Relation(
                    subject = r1.subject,
                    predicate = "å…³è”",
                    object = r2.object,
                    confidence = r1.confidence * r2.confidence
                ))
            }
        }

        return inferred
    }
}
```

**Q4: å¦‚ä½•å¯è§†åŒ–å¤§è§„æ¨¡çŸ¥è¯†å›¾è°±ï¼Ÿ**

A: ä½¿ç”¨åˆ†å±‚æ¸²æŸ“å’Œèšåˆï¼š

```typescript
// å‰ç«¯ä½¿ç”¨D3.jsæˆ–Cytoscape.js
import Cytoscape from 'cytoscape';

const cy = Cytoscape({
  container: document.getElementById('cy'),
  elements: {
    nodes: graph.entities.map(e => ({ data: { id: e.id, label: e.name } })),
    edges: graph.relations.map(r => ({ data: { source: r.subject, target: r.object, label: r.predicate } }))
  },
  layout: {
    name: 'cose',  // åŠ›å¯¼å‘å¸ƒå±€
    animate: true,
    nodeRepulsion: 400000
  }
});

// èšåˆå¤§è§„æ¨¡å›¾è°±
if (graph.entities.length > 100) {
  cy.layout({ name: 'preset' }).run();  // ä½¿ç”¨é¢„è®¾å¸ƒå±€
}
```

**Q5: å¦‚ä½•å¯¼å‡ºçŸ¥è¯†å›¾è°±ï¼Ÿ**

A: æ”¯æŒå¤šç§å¯¼å‡ºæ ¼å¼ï¼š

```kotlin
class GraphExporter {
    fun exportToJSON(graph: KnowledgeGraph): String {
        return Json.encodeToString(graph)
    }

    fun exportToGraphML(graph: KnowledgeGraph): String {
        return """
            <?xml version="1.0" encoding="UTF-8"?>
            <graphml>
                <graph id="G" edgedefault="directed">
                    ${graph.entities.joinToString("") {
                        """<node id="${it.id}"><data key="name">${it.name}</data></node>"""
                    }}
                    ${graph.relations.joinToString("") {
                        """<edge source="${it.subject}" target="${it.object}"><data key="label">${it.predicate}</data></edge>"""
                    }}
                </graph>
            </graphml>
        """.trimIndent()
    }

    fun exportToNeo4jCypher(graph: KnowledgeGraph): String {
        return graph.entities.joinToString("\n") {
            "CREATE (:Entity {id: '${it.id}', name: '${it.name}', type: '${it.type}'})"
        } + "\n" + graph.relations.joinToString("\n") {
            "MATCH (a:Entity {id: '${it.subject}'}), (b:Entity {id: '${it.object}'}) CREATE (a)-[:${it.predicate}]->(b)"
        }
    }
}
```

---

## é™„å½•

### APIå¯†é’¥é…ç½®

#### é˜¿é‡Œäº‘é€šä¹‰åƒé—®

```bash
# è·å–APIå¯†é’¥
1. è®¿é—® https://dashscope.console.aliyun.com/
2. ç™»å½•é˜¿é‡Œäº‘è´¦å·
3. è¿›å…¥"APIå¯†é’¥"é¡µé¢
4. åˆ›å»ºæ–°çš„APIå¯†é’¥
5. å¤åˆ¶å¯†é’¥åˆ°local.properties

# local.properties
QWEN_API_KEY=sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

#### Google Gemini

```bash
# è·å–APIå¯†é’¥
1. è®¿é—® https://ai.google.dev/
2. ç™»å½•Googleè´¦å·
3. åˆ›å»ºæ–°é¡¹ç›®
4. å¯ç”¨Gemini API
5. åˆ›å»ºAPIå¯†é’¥

# local.properties
GEMINI_API_KEY=AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

### æˆæœ¬ä¼˜åŒ–å»ºè®®

#### ç­–ç•¥1: è¯·æ±‚ç¼“å­˜

```kotlin
@Configuration
class CacheConfig {
    @Bean
    fun cacheManager(): CacheManager {
        return CaffeineCacheManager("ai-responses").apply {
            setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .maximumSize(10000))
        }
    }
}

@Service
class CachedAIService(
    private val aiService: AIService,
    private val cacheManager: CacheManager
) {
    @Cacheable(value = ["ai-responses"], key = "#request.hashCode()")
    suspend fun process(request: AIRequest): AIResponse {
        return aiService.process(request)
    }
}
```

#### ç­–ç•¥2: ç”¨é‡é…é¢

```kotlin
@Service
class QuotaManager {
    private val userQuotas = ConcurrentHashMap<String, AtomicInteger>()

    fun checkQuota(userId: String): Boolean {
        val quota = userQuotas.getOrPut(userId) { AtomicInteger(1000) }
        return quota.getAndDecrement() > 0
    }

    fun refillQuota(userId: String, amount: Int) {
        userQuotas.getOrPut(userId) { AtomicInteger(0) }.addAndGet(amount)
    }
}
```

#### ç­–ç•¥3: é™çº§ç­–ç•¥

```kotlin
@Service
class AIServiceWithFallback(
    private val primaryAIService: AIService,
    private val fallbackAIService: AIService
) {
    @CircuitBreaker(name = "ai-service", fallbackMethod = "fallback")
    suspend fun process(request: AIRequest): AIResponse {
        return primaryAIService.process(request)
    }

    private suspend fun fallback(request: AIRequest, ex: Exception): AIResponse {
        logger.warn("ä¸»æœåŠ¡å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æœåŠ¡: ${ex.message}")
        return fallbackAIService.process(request)
    }
}
```

### å¸¸è§é—®é¢˜FAQ

**Q1: å¦‚ä½•ç›‘æ§APIè°ƒç”¨æˆæœ¬ï¼Ÿ**

A: ä½¿ç”¨ç›‘æ§ä»ªè¡¨æ¿ï¼š

```kotlin
@Service
class CostMonitor {
    private val costMetrics = mutableMapOf<String, Double>()

    fun recordCost(apiName: String, cost: Double) {
        costMetrics[apiName] = (costMetrics[apiName] ?: 0.0) + cost
    }

    fun getCostReport(): Map<String, Double> {
        return costMetrics.toMap()
    }
}
```

**Q2: å¦‚ä½•å¤„ç†APIé™æµï¼Ÿ**

A: å®ç°ä»¤ç‰Œæ¡¶ç®—æ³•ï¼š

```kotlin
class RateLimiter(
    private val maxTokens: Int = 100,
    private val refillRate: Int = 10  // tokens/second
) {
    private val tokens = AtomicInteger(maxTokens)
    private val lastRefill = AtomicLong(System.currentTimeMillis())

    fun acquire(): Boolean {
        refillTokens()
        return tokens.getAndDecrement() > 0
    }

    private fun refillTokens() {
        val now = System.currentTimeMillis()
        val elapsed = (now - lastRefill.get()) / 1000
        val tokensToAdd = (elapsed * refillRate).toInt()

        if (tokensToAdd > 0) {
            tokens.updateAndGet { current ->
                minOf(current + tokensToAdd, maxTokens)
            }
            lastRefill.set(now)
        }
    }
}
```

**Q3: å¦‚ä½•å¤„ç†è¶…æ—¶ï¼Ÿ**

A: ä½¿ç”¨è¶…æ—¶å’Œé‡è¯•æœºåˆ¶ï¼š

```kotlin
suspend fun <T> withTimeout(
    timeoutMillis: Long,
    retries: Int = 3,
    block: suspend () -> T
): T {
    repeat(retries) { attempt ->
        try {
            return withTimeout(timeoutMillis) {
                block()
            }
        } catch (e: TimeoutCancellationException) {
            if (attempt == retries - 1) throw e
            delay(1000 * (attempt + 1))  // æŒ‡æ•°é€€é¿
        }
    }
    throw TimeoutException("Failed after $retries retries")
}
```

---

**æ–‡æ¡£ç»“æŸ**

Generated by Ingenio Platform
Date: 2025-11-11
Total AI Capabilities: 19
Documentation Version: v1.0.0
