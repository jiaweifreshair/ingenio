import { G3Artifact } from '@/types/g3';

const MOCK_BAD_CODE = `
// 这是一个计算斐波那契数列的函数
// Generated by Player Agent (Blue)

function fibonacci(n: number): number {
  if (n <= 1) return n;
  
  // 这里的语法是错误的，缺少赋值
  const result = ;
  
  return fibonacci(n - 1) + fibonacci(n - 2);
}
`;

const MOCK_FIXED_CODE = `
// 这是一个计算斐波那契数列的函数
// Fixed by Coach Agent (Red)

function fibonacci(n: number): number {
  if (n <= 1) return n;
  
  // 修复了语法错误
  const result = 0; // Placeholder or removed unnecessary line
  
  // 实际上上面的行是多余的，正确的递归如下:
  return fibonacci(n - 1) + fibonacci(n - 2);
}
`;

// Simulate network/inference delay
const simulateThinking = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export class PlayerAgent {
  static async generate(_requirement: string): Promise<G3Artifact> {
    await simulateThinking(1500); // Thinking...
    return {
      code: MOCK_BAD_CODE.trim(),
      filename: 'fibonacci.ts',
      language: 'typescript',
      isValid: false // Initially unknown, but we know it's bad
    };
  }
}

export class CoachAgent {
  static async fix(_code: string, _errors: string[]): Promise<G3Artifact> {
    await simulateThinking(2000); // Analyzing and fixing...
    
    // Simple mock logic: if we see the specific error we injected, return the fixed code.
    // In a real scenario, this would call an LLM with the code + error context.
    return {
      code: MOCK_FIXED_CODE.trim(),
      filename: 'fibonacci.ts',
      language: 'typescript',
      isValid: true // Hopefully fixed
    };
  }
}